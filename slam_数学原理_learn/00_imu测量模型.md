太好了 — 我把内容分成三部分：**参数定义 → 从连续模型到离散推导（含关键步骤）→ 一个具体、按位计算的数值例子**。所有公式都给出“**纯文本 / 可直接复制**”版（不使用 Markdown 数学渲染），以免你复制粘贴后显示出错。

---

# 一、参数与符号定义（纯文本）

* t：时间
* p(t) ∈ R^3：质心在世界坐标系下的位置
* v(t) ∈ R^3：速度（世界系）
* R(t) ∈ SO(3)：从 body（IMU）到 world 的旋转矩阵（也可写作 R_t）
* g ∈ R^3：重力向量（通常 g = [0, 0, -9.81]^T m/s^2，世界系向下为负）
* a(t)：IMU 在世界系下实际线加速度（不含重力）
* ω(t)：IMU 在 body（机体）坐标系测得的角速度（真实值，未含偏置噪声）
* ã(t)（tilde a）：IMU 加速度测量值（传感器读数）
* ω̃(t)（tilde omega）：IMU 角速度测量值（传感器读数）
* b_a(t)：加速度计偏置（随时间漂移）
* b_g(t)：陀螺仪偏置（随时间漂移）
* n_a(t)：加速度计测量噪声（白噪声）
* n_g(t)：陀螺仪测量噪声（白噪声）

IMU 测量模型（纯文本）：

```
ã(t) = R(t)^T * ( a(t) - g ) + b_a(t) + n_a(t)
ω̃(t) = ω(t) + b_g(t) + n_g(t)
```

系统动力学 continuous-time（纯文本）：

```
p_dot = v
v_dot = R * (ã - b_a - n_a) + g   // 注意：这里 ã 是传感器读数
R_dot = R * [ω̃ - b_g - n_g]_x     // [·]_x 表示反对称矩阵 (skew)
```

偏置模型（常用）– 随机游走（pure random walk）：

```
b_a_dot = n_ba  (n_ba 为白噪声)
b_g_dot = n_bg
```

---

# 二、从连续到离散（推导要点，纯文本）

我们要把连续模型离散化用于数值积分（例如每个 IMU 采样间隔 Δt）。常用方法有：显式欧拉（forward Euler）、中点法或四阶龙格—库塔。预积分通常用简单的离散近似 + 指数映射处理旋转（对角速度的指数映射）。

设在时刻 k 的采样间隔为 Δt_k，IMU 读数为 ã_k, ω̃_k（这是在区间 [t_k, t_k+1) 近似常数的假设）。

**旋转（使用指数映射）**
角增量（角矢量）：

```
theta_k = (ω̃_k - b_g) * Δt_k    // 这是 body-frame 的小角
ΔR_{k→k+1} = Exp( [theta_k]_x )  // 或记作 exp( [·]_x )
```

对于很小角度，Exp([θ]_x) ≈ I + [θ]_x （一阶近似）。

**速度与位置的离散更新（在“起始帧 i 的 body 坐标系”做预积分时）**
若我们用“预积分量” ΔR, Δv, Δp（都在起始 body_i 系表示），则每步更新为：

```
ΔR_{k+1} = ΔR_k * Exp( (ω̃_k - b_g) * Δt_k )

Δv_{k+1} = Δv_k + ΔR_k * (ã_k - b_a) * Δt_k

Δp_{k+1} = Δp_k + Δv_k * Δt_k + 0.5 * ΔR_k * (ã_k - b_a) * Δt_k^2
```

（这些等式是离散化的直接形式；实际实现里会在每步同时累积噪声雅可比矩阵与偏置雅可比）

**把预积分量转回世界系恢复状态**（已知起始状态 p_i, v_i, R_i）：

```
R_j = R_i * ΔR_ij
v_j = v_i + g * Δt_ij + R_i * Δv_ij
p_j = p_i + v_i * Δt_ij + 0.5 * g * Δt_ij^2 + R_i * Δp_ij
```

---

# 三、一阶偏置（bias）修正近似（纯文本 & 直觉）

预积分通常在某个“参考偏置” (b̄_a, b̄_g) 下完成；在优化过程中偏置会被更新为 b = b̄ + δb。我们不想重新积分全部数据，所以用一阶线性修正。

近似形式：

```
ΔR(b_g) ≈ ΔR_bar * Exp( J_R_bg * δb_g )
Δv(b) ≈ Δv_bar + J_v_ba * δb_a + J_v_bg * δb_g
Δp(b) ≈ Δp_bar + J_p_ba * δb_a + J_p_bg * δb_g
```

* Δ*_bar 是按旧偏置积分得到的预积分量（常作为缓存）。
* J_* 是在积分过程中累计的雅可比矩阵（预积分时同时计算并缓存它们）。
* 对于**单步**近似，旋转对陀螺仪偏置的雅可比 J_R_bg ≈ - I * Δt （在旋转矢量坐标下），因为增加陀螺偏置会在指数里产生负符号： Exp((ω - b_g - δb_g)Δt) ≈ Exp((ω - b_g)Δt) * Exp(-Δt * δb_g)。

直觉：陀螺偏置越大，实际积分到的角度会越小（符号相反），所以旋转修正是乘一个关于 δb_g 的小旋转。

---

# 四、噪声与协方差传播（点到点概念，纯文本）

线性化后，状态误差（包括旋转小量、速度、位置、偏置误差）的协方差在积分时用离散线性系统传播：

```
P_{k+1} = F_k * P_k * F_k^T + G_k * Q_k * G_k^T
```

* F_k：线性化的状态转移雅可比（关于误差状态）
* G_k：噪声输入映射
* Q_k：传感器噪声协方差矩阵（例如陀螺噪声方差、加速度噪声方差、偏置噪声方差）

在实现中，GTSAM / VINS 的 Preintegrator 会在每步同时累积 P、F、G 或直接累积噪声影响到 ΔR/Δv/Δp 的协方差矩阵。

---

# 五、**具体数值例子**（按位计算，单步与多步演示，纯文本 + 逐步算术）

**假设与约定（示例场景）**

* 世界系重力 g = [0, 0, -9.81]^T m/s^2。
* 初始状态（时刻 i）： p_i = [0,0,0]^T， v_i = [0,0,0]^T， R_i = I（单位阵）。
* 采样间隔 Δt = 0.01 s（100 Hz）。
* 偏置 b_a = 0， b_g = 0（为了看清核心数值，把偏置设零）。
* 噪声忽略（n_a = n_g = 0）。
* 传感器读数模拟：IMU **静止朝上**（即机体不动），因此物理加速度 a = 0（质心无加速度），但 IMU 加速度读数会包含重力项。根据测量模型：
  ã = R^T * (a - g) + b_a = I^T * (0 - [0,0,-9.81]) + 0 = [0,0,9.81]^T m/s^2。
* 角速度读数 ω̃ = [0, 0, 0.1]^T rad/s（微小绕 z 轴旋转 0.1 rad/s；实际设备可能静止，但这里举例让旋转项非零）。

我们做**单步积分**（从 k 到 k+1）：

1. 角增量（theta）：

```
theta = (ω̃ - b_g) * Δt = [0, 0, 0.1]^T * 0.01 = [0, 0, 0.001]^T  (rad)
```

逐位乘法：0.1 * 0.01 = 0.001 （注意：这是按位计算）

2. 旋转小量的反对称矩阵 [theta]_x：

```
[theta]_x = [ [ 0, -0.001, 0 ],
              [ 0.001,  0,   0 ],
              [ 0,      0,   0 ] ]
```

3. 近似的 ΔR (一阶)：
   对于小角，可用 ΔR ≈ I + [theta]_x。
   所以

```
ΔR = I + [theta]_x =
[ [1, -0.001, 0],
  [0.001, 1,  0],
  [0,    0,  1] ]
```

4. 计算 Δv 的增量（单步）：

```
increment_v = ΔR_prev * (ã_k - b_a) * Δt
```

初始 ΔR_prev = I，ã_k - b_a = [0,0,9.81], Δt = 0.01
逐位计算：9.81 * 0.01 = 0.0981
所以

```
increment_v = I * [0,0,9.81]^T * 0.01 = [0, 0, 0.0981]^T
```

因此更新：

```
Δv_{k+1} = Δv_k + increment_v = [0,0,0]^T + [0,0,0.0981]^T = [0,0,0.0981]^T
```

5. 计算 Δp 的增量（单步）：

```
Δp_{k+1} = Δp_k + Δv_k * Δt + 0.5 * ΔR_k * (ã_k - b_a) * Δt^2
```

初始 Δp_k = 0, Δv_k = 0, so first term zero.
计算 second term: 0.5 * I * [0,0,9.81] * (0.01)^2
(0.01)^2 = 0.0001
9.81 * 0.0001 = 0.000981
0.5 * 0.000981 = 0.0004905
所以

```
Δp_{k+1} = [0,0,0] + [0,0,0] + [0,0,0.0004905]^T = [0,0,0.0004905]^T
```

6. **用预积分结果恢复世界系的 v_{k+1} 和 p_{k+1}**（检验）：

```
v_{k+1} = v_i + g * Δt + R_i * Δv
```

计算 g * Δt = [0,0,-9.81] * 0.01 = [0,0,-0.0981]
R_i * Δv = I * [0,0,0.0981] = [0,0,0.0981]
相加： [0,0,-0.0981] + [0,0,0.0981] = [0,0,0]  // 速度仍为零 —— 符合静止物理事实
所以 v_{k+1} = [0,0,0] (与物理一致)

对位置：

```
p_{k+1} = p_i + v_i * Δt + 0.5 * g * Δt^2 + R_i * Δp
```

计算 0.5 * g * Δt^2:
Δt^2 = 0.0001
g * Δt^2 = [0,0,-9.81] * 0.0001 = [0,0,-0.000981]
0.5 * that = [0,0,-0.0004905]
R_i * Δp = [0,0,0.0004905]
相加： [0,0,-0.0004905] + [0,0,0.0004905] = [0,0,0]
再加 p_i and v_i*Δt (both zero) → p_{k+1} = [0,0,0]
也符合“静止”预期。

結论：单步预积分及恢复步骤数值一致，说明模型正确（即 IMU 测得的“静止下加速度9.81”被重力项抵消）。

---

## 六、把偏置扰动纳入单步修正的示例（简单直观数值）

假设在上面例子基础上，**如果我们误用了陀螺偏置** b̄_g = 0（积分时假设零），但真实偏置改为了 b_g = 0.01 rad/s（沿 z），则 δb_g = +0.01。

单步角度修正的近似（小角、单步）：

```
theta_true = (ω̃ - b_g) * Δt = (0.1 - 0.01) * 0.01 = 0.09 * 0.01 = 0.0009 rad
theta_bar  = (ω̃ - b̄_g) * Δt = 0.1 * 0.01 = 0.001 rad
差值 = theta_true - theta_bar = -0.0001 rad

由一阶修正形式：
ΔR_corr ≈ ΔR_bar * Exp( J_R_bg * δb_g )
对于单步，J_R_bg ≈ -I * Δt（在旋转矢量坐标系）
所以 J_R_bg * δb_g ≈ -Δt * δb_g = -0.01 * 0.01 = -0.0001  (沿 z)

这与上面直接计算的差值 -0.0001 rad 相同 —— 验证一阶修正直观正确。
```

---

# 七、小结（实战要点）

1. **参数清楚**：先把 g、R、bias、噪声定义清楚 —— 这是正确推导的前提。
2. **旋转用指数映射**：陀螺积分用 Exp 映射（或四元数），小角用一阶近似 I + [θ]_x。
3. **预积分与恢复公式**：Δv/Δp 是在起始机体系下累计的量，恢复到世界系时要加上 g、R_i 等项，从而抵消重力贡献（正是这个设计使得预积分对 g 的处理正确）。
4. **一阶 bias 修正**：积分时同时累积偏置雅可比（J），之后用线性近似快速修正，无需重新积分。
5. **数值验证**：用静止例子（ã=[0,0,9.81]）可以检验步骤正确性 —— 恢复的速度和位置应仍为零。

---

如果你想，我可以**马上**做下面任一件事（我会直接在这条回复中完成）：

* A）把上面详尽推导转成一个更“拷贝友好”的单文件 LaTeX（或纯文本 README），便于保存/打印；
* B）把偏置雅可比 J_v^{ba}, J_v^{bg}, J_p^{ba}, J_p^{bg} 的**逐项矩阵推导**写出来（比较长，但我会一步步给出），适合你实现代码时直接复制；
* C）把完整的单步更新写成一个小段 C++/Python 代码（含数值例子），你可以在本地运行并验证。

你想要哪一项？（直接回复 A/B/C 中的一项名字即可）
