你的理解 **完全正确**：
在 `--net=host` 模式下，Docker 容器 **和宿主机处于同一个网络命名空间**。因此容器和宿主机之间的访问方式，与宿主机本地应用之间的访问是 **一模一样的**。

下面我明确回答你的问题：

# ✔ Docker 使用 `--net=host` 时 **不需要再配置端口权限（端口映射）**

因为：

### 1. 容器与宿主机共享端口空间

* 容器内监听端口 = 宿主机监听端口
* 宿主机监听端口 = 容器监听端口
* 两者都在同一个网络栈下操作 **同一台机器的端口**
* 因此不需要 `-p 80:80` 或 `EXPOSE`

### 2. 访问方式完全一致

容器内服务监听：

```
0.0.0.0:14550
```

宿主机访问：

```
localhost:14550
```

容器内访问宿主机：

```
localhost:XXXX
```

根本不需要映射，也不需要 NAT。

### 3. 不需要额外权限

只要宿主机上普通用户可以绑定的端口（大于 1024），容器就同样可以绑定。
容器是 root 时，1024 以下端口也能绑定。

总结：

### **`--net=host` = 端口暴露、端口映射都不需要，也不能使用（因为没有意义）**

Dockerfile 里的 `EXPOSE` 在 Host 网络模式下也形同虚设。

---

# ❗ 什么情况下会需要“端口权限”？

仅当你使用默认的 Docker 桥接网络（bridge 模式）时：

```
docker run -p 14550:14550 myimage
```

因为此模式下容器网络是隔离的，需要端口映射才能让宿主机访问。

但你用了：

```
--net=host
```

所以这些都不需要。

---

# ✔ 但必须注意：**端口冲突**

因为容器直接使用宿主机端口：

* 如果宿主机已有程序占用 `14550`
* 容器内再运行 QGC 或 SITL 绑定 `14550`
* 会报错：
  `Address already in use`

你需要使用：

```
ss -lunp | grep 14550
```

来检查冲突。

---

# ✔ Proxy（http_proxy）不影响端口绑定

代理只影响所有显式走 HTTP(S) 的应用程序，例如 curl、apt、pip。
**不会影响容器绑定端口，也不会影响 MAVLink UDP、TCP 服务。**

---

# 📌 小结（非常重要）

| 项目                  | `--net=host`       |
| ------------------- | ------------------ |
| 是否需要 `-p` 端口映射？     | ❌ 不需要              |
| 能否绑定任意宿主机端口？        | ✔ 可以（同 root 权限）    |
| 宿主机访问容器？            | ✔ 用 localhost 同样方式 |
| 容器访问宿主机？            | ✔ 用 localhost 同样方式 |
| 是否可能端口冲突？           | ✔ 会（最高风险）          |
| proxy 是否影响 UDP/TCP？ | ❌ 不会               |

---

如果你愿意，我可以帮你检查当前 Docker 内外有哪些端口冲突风险。你只需要执行：

```
ss -lntup
ss -lntup
```

把结果发我，我帮你分析哪些端口正在被占用。
