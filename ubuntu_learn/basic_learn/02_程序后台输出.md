你现在用的是：

```bash
./apps/ADAS_Replay_Tool/bin/ADAS_Replay_Tool &
```

虽然加了 `&`，但一旦程序有输出到 **终端（stdout/stderr）**，仍会“占据”当前 TTY，而且你按下 `Ctrl+C` 时会发送 SIGINT 给前台进程组，**它依然会把你的程序杀掉**。

要真正让程序在后台运行，有几种标准方式：

---

# ✅ 方法 1：nohup（最常用、最稳的方式）

```bash
nohup ./apps/ADAS_Replay_Tool/bin/ADAS_Replay_Tool > run.log 2>&1 &
```

特点：

* 不受 `Ctrl+C`、SSH 断开影响
* 输出重定向到 `run.log`
* 程序独立运行

查看是否在后台：

```bash
ps -ef | grep ADAS_Replay_Tool
```

杀进程：

```bash
kill -9 <pid>
```

---

# ✅ 方法 2：使用 setsid（彻底脱离终端）

```bash
setsid ./apps/ADAS_Replay_Tool/bin/ADAS_Replay_Tool > run.log 2>&1 &
```

比 `nohup` 更“干净”，程序成为独立 Session，不属于终端。

---

# ✅ 方法 3：后台运行 + 禁止接受 Ctrl+C 的信号

（如果你非要使用 `&`）

```bash
./apps/ADAS_Replay_Tool/bin/ADAS_Replay_Tool >/dev/null 2>&1 </dev/null &
disown
```

`disown` 的作用：

* 把进程从当前 shell 的 job 列表移除
* 终端退出后也不会发送 HUP/KILL

---

# 🚀 推荐做法

你这种“车机 + AOS + ADAS 工具”场景，**强烈建议用 nohup**：

```bash
nohup ./apps/ADAS_Replay_Tool/bin/ADAS_Replay_Tool > /var/log/adas_replay.log 2>&1 &
```

---

# 📌 补充：如何查看后台程序输出？

```bash
tail -f run.log
```

---

# 📌 补充：后台程序挂掉了吗？

```bash
pgrep -laf ADAS_Replay_Tool
```

---

如果你愿意，我可以帮你写一个完整的后台启动脚本，比如：

* 自动重启
* 自动写 PID 文件
* 自动日志切割

要不要？
