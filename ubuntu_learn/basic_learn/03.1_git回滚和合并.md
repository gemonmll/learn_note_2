下面把 **Git 回滚**（撤销/回退）和 **合并**（merge/rebase 等）按“你实际会遇到的场景”讲透，并给你一套可直接套用的命令清单。重点放在：**AI agent 改乱了怎么回到稳定状态**，以及**分支怎么安全合并回主线**。

---

# 一、Git 回滚：你到底想“回到哪里”？

回滚/撤销在 Git 里最容易混淆的是：你要动的是哪个层级。

Git 主要有 4 个层级：

1. **工作区**：你磁盘上的文件（AI 改的就在这）
2. **暂存区**：`git add` 选中的“准备提交内容”
3. **本地提交历史**：`git commit` 形成的版本节点
4. **远程历史**：`git push` 上传后的版本

不同层级对应不同命令。下面按场景来。

---

## 场景 A：AI 改了一堆文件，但我还没 `add` / `commit`，我想全扔掉

**目标：丢弃工作区改动，回到最近一次提交状态**

```bash
git restore .
```

只丢某个文件：

```bash
git restore path/to/file
```

如果你还新增了很多未跟踪文件（比如 agent 生成了新文件），想一起删掉：

```bash
git clean -fd
```

> ⚠️ `git clean -fd` 会把未跟踪文件直接删除，慎用。建议先预览：`git clean -fdn`

---

## 场景 B：我已经 `git add .` 了，但还没 commit，后悔了（想取消暂存）

**目标：把暂存区退回工作区（改动还在，不丢）**

```bash
git restore --staged .
```

只取消某个文件暂存：

```bash
git restore --staged path/to/file
```

---

## 场景 C：我已经 commit 了，但没 push，想“回到上一个版本”

这时你有两条路：**reset（改历史）** 或 **revert（不改历史）**
如果还没 push、你自己一个人用，`reset` 很方便。

### C1）回到上一个提交，但保留改动（相当于“撤销提交，改动还在”）

```bash
git reset --soft HEAD~1
```

用途：提交信息写错了、想拆分提交、想重新挑文件再提交。

### C2）回到上一个提交，改动放回工作区（暂存区清空）

```bash
git reset --mixed HEAD~1
```

（默认就是 mixed）

### C3）回到上一个提交，并且把改动也全丢掉（危险）

```bash
git reset --hard HEAD~1
```

> ✅ AI 改炸了、你确定不要这些改动：常用 `--hard`
> ⚠️ 但如果你还想救回某些改动，别急着 hard，先用 soft/mixed 或看 `reflog`（下面讲）

---

## 场景 D：我已经 push 了（远程也有了），想撤回某次提交

这时**首选 `git revert`**，因为它**不改历史**，团队协作最安全。

### D1）revert 某个提交（生成一个“反向提交”）

```bash
git revert <commit_hash>
git push
```

### D2）revert 一段范围（把一串提交都反做）

```bash
git revert <old_commit>.. <new_commit>
```

> ✅ 什么时候用 revert：
>
> * 提交已经 push 到远程
> * 可能别人基于这些提交继续开发了
> * 你不想强制别人处理历史改写
>
> ✅ 什么时候可以 reset：
>
> * 只在本地，或你确定没人基于远程分支工作
> * 或者这是你个人分支，随便你重写

---

## 场景 E：我 reset --hard 了，发现后悔了，还能救吗？

大概率能。用 **reflog** 找回“刚才的 HEAD 在哪”。

```bash
git reflog
```

你会看到类似：

* `HEAD@{0}` 你当前
* `HEAD@{1}` 你刚才 reset 前的状态

然后回去：

```bash
git reset --hard HEAD@{1}
```

> reflog 是“本地操作日志”，非常救命。只要你没做太多清理，一般都能找回。

---

## 场景 F：只想回滚某个文件到某个版本，不影响其他文件

```bash
git restore --source <commit_hash> -- path/to/file
```

或者回到上一次提交版本：

```bash
git restore -- path/to/file
```

---

## 场景 G：回到某个历史版本“看看”，但不想改动当前分支

你可以临时切到某个提交（Detached HEAD）：

```bash
git checkout <commit_hash>
```

想回去：

```bash
git checkout main
```

如果你在那个历史点上想继续改并形成新分支：

```bash
git checkout -b hotfix-from-old <commit_hash>
```

---

# 二、Git 合并：merge / rebase / squash 到底怎么选？

合并的目标是：把一个分支的改动带到另一个分支。常见是：

* `agent/xxx` → `main`

你会遇到三种主流方式：

1. **merge（合并提交保留分支历史）**
2. **rebase（改写提交基底，让历史更线性）**
3. **squash（把一堆提交压成一个）**

---

## 1）merge：最直观、最安全（团队协作默认推荐）

假设你在 `agent/xxx` 做完了，想合并到 main：

```bash
git checkout main
git pull
git merge agent/xxx
git push
```

### merge 可能出现两种结果：

#### A) Fast-forward（快进）

如果 main 没有新提交，Git 直接把 main 指针快进到 agent 的最新提交。
历史是线性的，没有“合并提交”。

#### B) 三方合并（会产生一个 merge commit）

如果 main 也有新提交，Git 会做一次真正的合并，并产生一个“Merge commit”。

> 想强制产生 merge commit（保留“这是一个分支合并”的信息）：

```bash
git merge --no-ff agent/xxx
```

---

## 2）合并冲突怎么处理（AI 改代码经常会碰到）

当两个分支同时改了同一段代码，merge 会提示冲突：

常用流程：

1. 执行 merge

```bash
git merge agent/xxx
```

2. 看冲突文件：

```bash
git status
```

3. 打开冲突文件，会看到：

```text
<<<<<<< HEAD
main 分支内容
=======
agent 分支内容
>>>>>>> agent/xxx
```

4. 手动改成你要的样子，删掉冲突标记。

5. 标记冲突已解决并提交：

```bash
git add <冲突文件>
git commit
```

### 冲突合并过程中想放弃本次 merge

```bash
git merge --abort
```

---

## 3）rebase：历史更“直线”，但会改写提交（谨慎用）

常用场景：你在 `agent/xxx` 开发期间，main 有人更新了，你想把最新 main “叠”到你的分支上，减少未来合并冲突。

在你的分支上做：

```bash
git checkout agent/xxx
git fetch origin
git rebase origin/main
```

解决冲突后：

```bash
git add <文件>
git rebase --continue
```

想放弃 rebase：

```bash
git rebase --abort
```

> ⚠️ 重要原则：
> **不要 rebase 已经推送并被别人基于其开发的公共分支。**
> 因为 rebase 会改提交哈希，别人会很痛苦。
>
> ✅ 推荐用法：
>
> * 你个人分支（比如 agent/xxx）随便 rebase
> * main/master 这种公共分支尽量只 merge 或通过 PR 合并

如果你 rebase 过的分支之前 push 过，需要强推：

```bash
git push --force-with-lease
```

> `--force-with-lease` 比 `--force` 安全一些（会检查远程是否被别人更新过）

---

## 4）squash：把一堆“AI 试错提交”压成一个干净提交

AI agent 往往会产生很多“wip”“try fix”提交，你可能想合并时只留一个。

### A) 合并时 squash（最简单）

在 main 上：

```bash
git checkout main
git merge --squash agent/xxx
git commit -m "feat: agent changes for xxx"
git push
```

这会把 agent 分支的最终效果压成一个提交，但不会保留它的提交历史。

### B) 交互式 rebase squash（更细）

在 agent 分支：

```bash
git rebase -i HEAD~N
```

把后面的 commit 从 `pick` 改成 `squash` / `fixup`，整理成你想要的历史。

---

# 三、给 AI agent 的最佳实践（回滚 + 合并组合拳）

## 推荐流程（稳、可控、好回退）

1. main 保持干净可运行
2. 每次 agent 大改：

```bash
git checkout -b agent/task
git commit -am "chore: baseline before agent"
# 运行 agent
git status
git diff
git add -p
git commit -m "feat: agent implemented task"
git push -u origin agent/task
```

3. 合并回 main：

* 团队协作/想保留分支痕迹：`merge --no-ff`
* 想让 main 历史更干净：`merge --squash`

---

# 四、速查：回滚与合并最常用命令清单

**回滚：**

* 丢弃工作区改动：`git restore .`
* 取消暂存：`git restore --staged .`
* 撤销最后一次提交（保留改动）：`git reset --soft HEAD~1`
* 彻底回到上个提交（丢改动）：`git reset --hard HEAD~1`
* 已 push 的撤回：`git revert <hash>`
* 救命找回：`git reflog`

**合并：**

* 合并分支：`git merge agent/xxx`
* 强制保留合并提交：`git merge --no-ff agent/xxx`
* 压成一个提交：`git merge --squash agent/xxx`
* 合并冲突放弃：`git merge --abort`
* 线性整理：`git rebase origin/main` / `git rebase --continue` / `git rebase --abort`

---

如果你告诉我你现在的分支模型（比如 main/dev 还是 trunk-based）、以及 agent 通常是“改很多文件”还是“改同一片代码”，我可以直接给你定一套最适合的策略：**merge 还是 squash，什么时候 rebase，冲突怎么降到最低**。
