从你截图看：

* 第一次 `git merge feature/jzm_develop` **已经合并成功并提交完成**（`Merge made by the 'ort' strategy.`）。
* 所以 `git merge --abort` 才会报：**MERGE_HEAD missing**（因为你已经不在“合并进行中”状态了）。

要“取消已经成功的 merge”，分两种情况：

---

## 情况 1：还没 push（最简单，直接回到合并前）

你已经在截图里执行了这一条，它就是正确做法：

```bash
git reset --hard ORIG_HEAD
```

做完后用下面确认一下是否回退成功：

```bash
git log --oneline --decorate -n 5
git status
```

如果你担心 ORIG_HEAD 不对，最稳的方式是用 reflog 找回退点：

```bash
git reflog -n 20
# 找到 merge 之前那条（通常是 HEAD@{1} 或者写着 “before merge” 的）
git reset --hard HEAD@{1}
```

---

## 情况 2：已经 push 到远端了（不要 reset 回退历史，用 revert 生成反向提交）

先找到那个 **merge commit**：

```bash
git log --oneline --decorate --graph -n 20
```

然后回退这个 merge（保留主分支那条主线，一般是 `-m 1`）：

```bash
git revert -m 1 <merge_commit_hash>
git push origin <你的当前分支名>
```

---

### 你现在该用哪个？

* **如果你合并后还没 `git push`**：用 `git reset --hard ORIG_HEAD`（你已经做对了）。
* **如果已经 push 了**：用 `git revert -m 1 ...`。

你把下面两条输出贴一下（5 行以内），我可以直接告诉你现在处于哪种情况、下一步该怎么敲：

```bash
git log --oneline --decorate -n 6
git reflog -n 10
```

-----

git reset 回退节点
你这个 reflog 很清楚：你现在 `HEAD` 在 `195ca15`，而你想回到 `45363a1`（也就是 `origin/main` 指向的那个提交）。

你有两种“回到 45363a1”的做法，选一种就行：

## 做法 1：硬回退到 45363a1（推荐你这种“我要回到某个提交点”）

⚠️ 会把当前分支（你现在是 `main`）的工作区/暂存区都回到那个提交状态，且会丢弃之后的本地提交（这里就是 `reset/revert` 产生的那些）。

```bash
git reset --hard 45363a1
```

然后看一下：

```bash
git log --oneline --decorate -n 5
git status
```

### 如果你已经把 `195ca15` push 到远端了

那还需要把远端 `main` 也改回去（谨慎，可能影响别人）：

```bash
git push --force-with-lease origin main
```

---

## 做法 2：让 main “跟随远端”回到 origin/main（更语义化）

如果你的目标就是“回到远端当前的 main”，用这个更直观：

```bash
git fetch origin
git reset --hard origin/main
```

（因为 reflog 里显示 `origin/main` 就是 `45363a1`）

---

## 你说的“我要到 HEAD@{4} 那条”

也可以直接用 reflog 引用：

```bash
git reset --hard HEAD@{4}
```

---

### 我帮你核对一下：你现在有没有 push 过？

执行：

```bash
git status -sb
```

* 如果显示 `ahead of 'origin/main' by ... commits`，说明你本地比远端新（可能需要你决定要不要 `push --force-with-lease`）。
* 如果没有 ahead，那你 reset 完基本就结束了。

