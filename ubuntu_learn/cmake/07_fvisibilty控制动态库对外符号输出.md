不是 `PUBLIC`。
**控制动态库（.so）对外可见的符号**不属于 CMake 的 `PUBLIC/PRIVATE/INTERFACE` 范畴。
它属于 **ELF 导出符号控制**，和“链接依赖传播”完全不同的概念。

我给你一个完整、实战的解释，按顺序从简单到专业。

---

# ✅ 一句话结论

要控制 `.so` 输出哪些符号，你应该用：

---

# **✔ 方法 1：使用“符号版本脚本（Version Script）” —— 最专业、可控性最高**

这是 Linux/ELF 的官方机制。

---

# **✔ 方法 2：使用编译器隐藏属性（-fvisibility）+ API 宏 —— 大型项目通用方式**

适合 C++ 项目，控制导出类、函数。

---

# ❌ PUBLIC / PRIVATE 与符号导出无关

它们是 CMake 影响**依赖关系传播**的概念，而不是控制 ELF 导出符号的机制。

---

# ⬇️ 我给你详细讲 2 种正确方法

---

# ---------------------------------------------------------

# 🔥 方法 1：使用 Version Script 控制导出符号（最推荐）

# ---------------------------------------------------------

例如，你想让 `.so` 里只导出：

```
foo()
bar()
```

其他符号全部隐藏。

你写一个文件：`export.map`

```text
{
    global:
        foo;
        bar;
    local:
        *;
};
```

然后 CMake：

```cmake
set_property(TARGET MyLib APPEND_STRING PROPERTY
    LINK_FLAGS " -Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/export.map"
)
```

这样生成的 `.so`：

* **只导出 foo 和 bar**
* 所有其他内部函数全部隐藏（不会污染外部符号表）
* 对 C++ ABI 非常友好
* 完全符合 Linux ELF 规范

---

# ---------------------------------------------------------

# 🔥 方法 2：使用可见性控制（-fvisibility）+ 导出宏

# ---------------------------------------------------------

你可以整体禁止导出符号：

```cmake
add_compile_options(-fvisibility=hidden)
```

然后你自己想导出的类或函数前面加宏：

## 头文件中

```cpp
#if defined(_WIN32)
    #define API_EXPORT __declspec(dllexport)
#else
    #define API_EXPORT __attribute__((visibility("default")))
#endif
```

## 导出的函数写：

```cpp
API_EXPORT void foo();
```

## 不加 API_EXPORT 的函数不会导出 ✔

---

# 🔍 两者的区别和什么时候用哪个？

| 方式                   | 特点                    | 场景                 |
| -------------------- | --------------------- | ------------------ |
| **Version Script**   | 最专业、控制最严格、支持 C/C++ 混合 | **大型组件、框架、底层库**    |
| **-fvisibility + 宏** | C++ 项目最常用、语法简单        | **接口类较多的 C++ 动态库** |

---

# ---------------------------------------------------------

# 🧪 验证方法：查看 `.so` 的导出符号

# ---------------------------------------------------------

```bash
nm -D libmylib.so
```

或：

```bash
objdump -T libmylib.so
```

你将看到哪些符号被导出，哪些被隐藏。

---

# ---------------------------------------------------------

# ⚠️ CMake 的 PUBLIC / PRIVATE 是做什么的？

# ---------------------------------------------------------

| 关键字       | 作用                 |
| --------- | ------------------ |
| PRIVATE   | 仅影响当前 target       |
| PUBLIC    | 当前 target + 使用者都继承 |
| INTERFACE | 仅继承，不影响当前 target   |

它们影响的是：

* include 目录传播
* 链接库传播
* 编译选项传播

👇 **不是：**

* 不是控制 ELF 导出符号
* 不是控制 .so 向外暴露哪些函数

---

# ---------------------------------------------------------

# 🧩 最推荐你的使用策略（结合你的项目）

# ---------------------------------------------------------

你现在做的是：

* 大型 ADAS 组件
* 动态库依赖很多 third-party 库（IPC、ARA、ZLToolKit 等）

**最佳实践：**

### ✔ 1. 默认隐藏所有符号（减少冲突）

```cmake
add_compile_options(-fvisibility=hidden)
```

### ✔ 2. 提供 API 宏，统一管理导出

```cpp
#define API __attribute__((visibility("default")))
```

### ✔ 3. 导出必要的接口

```cpp
API int Init();
API void Start();
API void Stop();
```

### ✔ 4. 重要库（如 ZLToolKit）仍使用 INTERFACE传播依赖（不影响符号）

### ✔ 5. 如果需要极强控制（比如你是写平台框架层）→ 用 version script

---

# 🎁 想要吗？

如果你把你的 `.so` 作为 SDK 提供给别人，我可以帮你做：

🔹 完整的符号导出设计
🔹 CMake 自动控制 visibility
🔹 导出头文件 API 设计优化
🔹 版本脚本自动生成
🔹 完整示例可运行工程模板

你只需要告诉我：

> “你的哪些函数 / 类需要对外暴露？”

我就能帮你写出专业级别的导出策略。
