这是一个非常经典的 Linux C++ “深坑”。简单来说，`_GLIBCXX_USE_CXX11_ABI` 是为了解决 **C++11 标准对 `std::string` 的新要求**而引入的一个开关。

当你看到字符串被截断成 4 个字节或者程序莫名崩溃时，通常是因为你的程序和链接的库（如 GFlags）在 **“如何理解一个 `std::string` 的内存结构”** 上产生了分歧。

---

### 1. 为什么会有两个 ABI？

在 GCC 5.1 发布之前，`std::string` 的实现采用的是 **写时复制（Copy-On-Write, COW）** 技术。

* **旧 ABI (`_GLIBCXX_USE_CXX11_ABI=0`)**：多个 string 对象可以共享同一块内存，只有在修改时才真正复制。
* **新 ABI (`_GLIBCXX_USE_CXX11_ABI=1`)**：由于 C++11 标准要求字符串的某些操作必须是线程安全的，且禁止了 COW，因此 GCC 重新设计了 `std::string`，引入了 **短字符串优化（Small String Optimization, SSO）**。

### 2. 内存布局的巨大差异

这就是为什么你的程序会读到乱码或截断的原因：

| 特性 | 旧 ABI (COW) | 新 ABI (SSO) |
| --- | --- | --- |
| **内部结构** | 只有一个指针，指向一个包含引用计数、长度和数据的结构体。 | 包含一个本地缓冲区（用于存短字符串）和长度信息。 |
| **对象大小** | 通常是 8 字节（仅一个指针）。 | 通常是 32 字节（包含 buffer）。 |
| **数据位置** | 真正的字符存储在堆内存的偏移位置。 | 短字符串存栈上（对象内部），长字符串存堆上。 |

**为什么你看到了 `"/hom"`？**
因为在旧 ABI 下，`std::string` 对象的起始位置就是一个指向字符阵列的指针。如果你的主程序按新 ABI 去解析，它可能会把这个“指针”的前 4 个字节误当成了字符串的实际内容打印出来，于是就出现了截断。

---

### 3. 如何检测库的 ABI 版本？

如果你不确定你链接的 `.a` 或 `.so` 文件是用哪个 ABI 编译的，可以使用 `nm` 工具查看符号名：

```bash
# 查看库文件中引用的 string 符号
nm -C libgflags.a | grep "std::string"

```

* **旧 ABI**：符号名通常包含 `std::string`。
* **新 ABI**：符号名会包含 `std::cxx11::string`。

如果你发现库里全是 `[abi:cxx11]`，而你的报错指向普通的 `std::string`，那说明你的编译器默认没开 C++11 ABI。

---

### 4. 解决方案

要解决这个问题，必须保证**整个链路**（所有第三方库和你自己的代码）使用相同的 ABI。

#### 方案 A：修改 CMake（最常用）

在 `CMakeLists.txt` 中全局强制定义宏：

```cmake
# 如果你的库是旧的（常见于一些闭源 SDK 或老系统库）
add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)

# 如果你的库是新的
add_definitions(-D_GLIBCXX_USE_CXX11_ABI=1)

```

#### 方案 B：修改全局编译标志

```cmake
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D_GLIBCXX_USE_CXX11_ABI=0")

```

#### 方案 C：重编译第三方库（最彻底）

如果你有 GFlags 的源码，建议直接用你当前的编译器重新编译 GFlags。这样它就会自动匹配你主程序的默认 ABI，避免手动设置宏带来的维护麻烦。

---

### 总结

你遇到的 `argc` 正确但变量值错误的情况，是典型的 **“对象内存视图不一致”**。库函数把数据填进了“旧房子”，你的程序却按“新图纸”去领钥匙，结果自然对不上。

**建议：** 你可以先尝试在 `CMakeLists.txt` 里设置 `_GLIBCXX_USE_CXX11_ABI=0` 看看能否恢复正常。如果恢复了，说明你链接的某个关键库（比如 GFlags）是基于旧版 ABI 编译的。

需要我帮你写一段自动检测 ABI 并设置的 CMake 脚本吗？