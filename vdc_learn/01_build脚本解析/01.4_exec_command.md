下面我帮你 **详细分析 `exec_command` 函数的作用、参数、执行机制、为什么这么写，以及注意事项**。

这是一个在大型工程（尤其 build 系统）中常见的 Shell 工具函数。

---

# ✅ **这段代码的功能是什么？**

```bash
function exec_command() {
    local readonly working_directory="$1"
    local readonly command="$2"
    if [ ! -d "$working_directory" ]; then
        echo "${FUNCNAME}: cannot find working directory '$working_directory'" >&2
        return 1
    fi
    pushd "$working_directory" > /dev/null
    $command
    popd > /dev/null
}
```

👉 **在指定目录下执行一条命令，执行完后自动回到原目录。**

---

# 🧩 **1. 参数解析（非常重要）**

`exec_command $working_directory $command`

例如：

```bash
exec_command "/home/project/build" "cmake .."
```

那么：

* `$1` = `/home/project/build`
* `$2` = `"cmake .."`

脚本会自带切换目录、执行命令、再切回原来路径。

---

# 🧩 **2. 检查路径是否存在**

```bash
if [ ! -d "$working_directory" ]; then
    echo "${FUNCNAME}: cannot find working directory '$working_directory'" >&2
    return 1
fi
```

防止进入不存在的目录造成脚本崩溃。

`${FUNCNAME}` 自动填入当前函数名，在报错防调试。

---

# 🧩 **3. pushd 和 popd 的作用**

### 🔵 pushd = 切换目录并压栈

进入一个目录，但是会把当前目录加入一个目录栈。

```bash
pushd "$working_directory"
```

### 🔵 popd = 出栈并切回原目录

```bash
popd
```

### 🔥 这就保证：

无论你在哪个目录执行脚本，执行完命令后，都能回到原来的目录。

这是 build 系统非常重要的特性，因为 CMake / make / ninja 都会大量切换目录。

---

# 🧩 **4. 静默输出**

为了不污染构建输出：

```bash
> /dev/null
```

pushd 和 popd 默认会打印路径，为避免输出干扰，加了：

* `pushd ... > /dev/null`
* `popd > /dev/null`

---

# 🧩 **5. 执行命令**

```bash
$command
```

这句执行传入的命令字符串。

例如：

```bash
exec_command "/project/target" "make -j8"
```

最终执行：

```
cd /project/target
make -j8
cd 回原路径
```

---

# 🎯 **6. 整个函数执行流程图**

```
exec_command "/a/b" "cmake .."

↓ 检查 /a/b 是否存在
↓ pushd 到 /a/b
    （目录切换）
↓ 执行 "cmake .."
↓ popd（回到原目录）
```

---

# 🔥 **7. 使用场景**

在大型 build 框架中非常常见：

### ✔ 在某个指定目录下生成 CMake 构建文件

```bash
exec_command "$TARGET_DIR" "cmake -DCMAKE_TOOLCHAIN_FILE=xxx.cmake $SRC_DIR"
```

### ✔ 在 target 目录中执行 make

```bash
exec_command "$TARGET_DIR" "make -j8"
```

### ✔ 在 running 目录复制文件

```bash
exec_command "$RUNNING_DIR" "cp $BIN ."
```

---

# 🧠 **8. 为什么不用直接 cd？**

如果你写：

```bash
cd xxx
cmake ..
cd -
```

缺点：

* cd - 只保存一个目录，不可靠
* 遇到错误可能丢失当前目录
* 和子脚本嵌套时更容易搞乱工作目录

而 pushd/popd 维护一个栈：

```
/a/b/c
pushd /foo
pushd /bar
popd  <-- 回 /foo
popd  <-- 回 /a/b/c
```

非常安全。

---

# 📌 **9. 使用 exec_command 的正确用法**

例如：

```
exec_command "$TARGET_FOLDER" "cmake .."
exec_command "$TARGET_FOLDER" "make -j8"
exec_command "$SCRIPT_FOLDER" "./some_tool.sh"
```

---

# 📝 **10. 简要总结（记住这三点即可）**

| 功能      | 描述         |
| ------- | ---------- |
| 切换工作目录  | 用 pushd    |
| 执行命令    | `$command` |
| 执行完自动返回 | 用 popd     |

这就是一个安全的 “在其它目录执行命令” 工具方法。

---

如果你愿意，我还能帮你继续分析：

* build_project() 里如何调用 exec_command
* bootstrap.sh 的全流程
* 整个构建系统的执行顺序
* 如何扩展 exec_command 支持管道命令

想继续深挖哪个部分？
