ROS çš„**æ—¶é—´åŒæ­¥ï¼ˆmessage synchronizationï¼‰**æœ¬è´¨æ˜¯ï¼š

> **æŠŠä¸åŒ topic çš„æ¶ˆæ¯æŒ‰æ—¶é—´å¯¹é½ï¼Œè®©ç®—æ³•æ”¶åˆ°â€œåŒä¸€æ—¶åˆ»â€çš„ä¼ æ„Ÿå™¨æ•°æ®ã€‚**

ä¸¾ä¾‹ï¼š
ç›¸æœº `/camera` 30Hzã€IMU `/imu` 200Hzã€‚
ä½ å¸Œæœ›å¾—åˆ°ï¼š

```
t=1.000s çš„ç›¸æœºå›¾åƒ + æœ€æ¥è¿‘ 1.000s çš„ IMU æ•°æ®
```

ROS ä¸­å¸¸ç”¨ä¸¤ç§åŒæ­¥æ–¹å¼ï¼š

---

# âœ… **1. ä½¿ç”¨ ROS å®˜æ–¹ message_filtersï¼ˆæ¨èï¼‰**

è¿™æ˜¯ ROS1 å®˜æ–¹æä¾›çš„åŒæ­¥åº“ï¼Œé€‚åˆåœ¨çº¿ï¼ˆå®æ—¶ï¼‰å¤„ç†ã€‚

---

## **1.1 ç²¾ç¡®åŒæ­¥ï¼ˆExactTimeï¼‰â€”â€”ä¸¥æ ¼è¦æ±‚æ—¶é—´æˆ³ç›¸åŒ**

é€‚ç”¨äºå¤šç›¸æœºã€å¤šé›·è¾¾ï¼Œè¦æ±‚å¸§æ—¶é—´æˆ³å®Œå…¨ä¸€è‡´ã€‚

```cpp
#include <ros/ros.h>
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/exact_time.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/Imu.h>

using namespace message_filters;

void callback(const sensor_msgs::ImageConstPtr& img,
              const sensor_msgs::ImuConstPtr& imu)
{
    ROS_INFO("Image time: %.6f  IMU time: %.6f",
             img->header.stamp.toSec(),
             imu->header.stamp.toSec());
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "sync_exact");
    ros::NodeHandle nh;

    message_filters::Subscriber<sensor_msgs::Image> sub_img(nh, "/camera", 10);
    message_filters::Subscriber<sensor_msgs::Imu> sub_imu(nh, "/imu", 100);

    typedef sync_policies::ExactTime<
        sensor_msgs::Image,
        sensor_msgs::Imu
    > SyncPolicy;

    Synchronizer<SyncPolicy> sync(SyncPolicy(10), sub_img, sub_imu);
    sync.registerCallback(boost::bind(&callback, _1, _2));

    ros::spin();
    return 0;
}
```

### âš ï¸ ExactTime çš„ç¼ºç‚¹

* è¦æ±‚ä¸¤ä¸ª message æ—¶é—´æˆ³å¿…é¡»å®Œå…¨ç›¸åŒï¼ˆæéš¾åšåˆ°ï¼‰
* ä¸€èˆ¬ IMUã€Image çš„æ—¶é—´å¯¹ä¸ä¸Šï¼Œæ— æ³•æˆåŠŸå¯¹é½

æ‰€ä»¥çœŸå®å·¥ç¨‹ä¸­æ›´å¸¸ç”¨ ApproximateTimeã€‚

---

# âœ… **2. è¿‘ä¼¼åŒæ­¥ï¼ˆApproximateTimeï¼‰â€”â€”å·¥ç¨‹æœ€å¸¸ç”¨**

å…è®¸å‡ æ¯«ç§’è¯¯å·®ï¼Œé€‚åˆç›¸æœº + IMUã€å¤šç›¸æœºã€å¤šé›·è¾¾ç­‰ç»„åˆã€‚

```cpp
#include <ros/ros.h>
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/Imu.h>

using namespace message_filters;

void callback(const sensor_msgs::ImageConstPtr& img,
              const sensor_msgs::ImuConstPtr& imu)
{
    ROS_INFO("Sync -> Image: %.6f   IMU: %.6f",
             img->header.stamp.toSec(),
             imu->header.stamp.toSec());
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "sync_approx");
    ros::NodeHandle nh;

    message_filters::Subscriber<sensor_msgs::Image> sub_img(nh, "/camera", 10);
    message_filters::Subscriber<sensor_msgs::Imu> sub_imu(nh, "/imu", 100);

    typedef sync_policies::ApproximateTime<
        sensor_msgs::Image,
        sensor_msgs::Imu
    > SyncPolicy;

    Synchronizer<SyncPolicy> sync(SyncPolicy(50), sub_img, sub_imu);
    sync.registerCallback(boost::bind(&callback, _1, _2));

    ros::spin();
    return 0;
}
```

### ç‰¹ç‚¹

* é»˜è®¤è¯¯å·®çº¦ Â±10msï¼Œå¯æ ¹æ®å¸§ç‡è°ƒå¤§é˜Ÿåˆ—é•¿åº¦ï¼Œæ¯”å¦‚ 50
* èƒ½è‡ªåŠ¨æ‰¾å‡ºæœ€é è¿‘çš„ IMU æ•°æ®

---

# âœ… **3. å¦‚æœä½ è¦ç¦»çº¿åŒæ­¥ï¼ˆè§£æ rosbagï¼‰**

å®æ—¶åŒæ­¥æ˜¯ message_filters çš„å¼ºé¡¹ã€‚
ä½†å¾ˆå¤šå·¥ç¨‹éœ€è¦ **ç¦»çº¿åŒæ­¥**ï¼ˆSLAMã€ä¼ æ„Ÿå™¨æ ‡å®šã€ç¦»çº¿è°ƒè¯•ï¼‰ã€‚

ä¸¾ä¾‹ï¼š**æŒ‰å›¾åƒæ—¶é—´æˆ³æ‰¾æœ€æ¥è¿‘çš„ IMU**ï¼š

---

## **3.1 æ‰‹åŠ¨åŒæ­¥ç®—æ³•ï¼ˆç¦»çº¿æœ€å¸¸ç”¨ï¼‰**

```cpp
template<typename T>
T findClosest(const std::vector<T>& data, ros::Time t)
{
    double min_diff = 999999;
    T best;

    for (auto& d : data) {
        double diff = fabs((d->header.stamp - t).toSec());
        if (diff < min_diff) {
            min_diff = diff;
            best = d;
        }
    }
    return best;
}
```

ç„¶ååœ¨è¯»å– bag æ—¶ï¼š

```cpp
sensor_msgs::ImageConstPtr img = ...
sensor_msgs::ImuConstPtr imu = findClosest(imu_buffer, img->header.stamp);
```

---

## **3.2 å·¥ç¨‹çº§åŒæ­¥æ–¹æ³•ï¼šæ—¶é—´çª—å£å†…æœç´¢**

é€‚åˆ IMU é«˜é¢‘ã€ç›¸æœºä½é¢‘ï¼š

```cpp
std::vector<sensor_msgs::ImuConstPtr> imu_buffer;

// å‡è®¾ img æ—¶é—´æˆ³ä¸º t
double window = 0.01; // 10ms

std::vector<sensor_msgs::ImuConstPtr> matched_imu;
for (auto& imu : imu_buffer) {
    if (fabs((imu->header.stamp - img->header.stamp).toSec()) < window)
        matched_imu.push_back(imu);
}
```

ç”¨äºï¼š

* æ»¤æ³¢å™¨ï¼ˆEKFï¼‰
* é¢„ç§¯åˆ†ï¼ˆVIOï¼‰
* å¤šä¼ æ„Ÿå™¨èåˆ

---

# âœ… **4. é«˜çº§ï¼šåŒæ­¥å¤šä¸ª topicï¼ˆä¸‰ä¸ªåŠä»¥ä¸Šï¼‰**

å¦‚ï¼šå›¾åƒ + IMU + ç‚¹äº‘ï¼š

```cpp
typedef sync_policies::ApproximateTime<
    sensor_msgs::Image,
    sensor_msgs::Imu,
    sensor_msgs::PointCloud2
> MySyncPolicy;

Synchronizer<MySyncPolicy> sync(MySyncPolicy(50), sub_img, sub_imu, sub_lidar);
sync.registerCallback(boost::bind(&callback, _1, _2, _3));
```

---

# ğŸ”¥ æ€»ç»“ï¼šå¦‚ä½•é€‰æ‹©åŒæ­¥æ–¹å¼ï¼Ÿ

| åœºæ™¯                  | æ¨èæ–¹å¼                             |
| ------------------- | -------------------------------- |
| åœ¨çº¿å®æ—¶åŒæ­¥ï¼ˆä¼ æ„Ÿå™¨åŸå§‹ topicï¼‰ | message_filters::ApproximateTime |
| æ—¶é—´æˆ³ä¸¥è‹›ï¼ˆå¤šç›¸æœºï¼ŒåŒç›®ï¼‰       | ExactTime                        |
| SLAM/VIO ç¦»çº¿å¤„ç†       | æ‰‹åŠ¨åŒæ­¥ï¼ˆnearest neighborï¼‰           |
| IMU é«˜é¢‘ï¼Œéœ€è¦çª—å£å¤„ç†       | æ—¶é—´åŒºé—´åŒæ­¥                           |

---

# ä½ ç°åœ¨çš„éœ€æ±‚æ˜¯å“ªç§ï¼Ÿ

æˆ‘å¯ä»¥å¸®ä½ å†™ä¸€ä¸ªå®Œæ•´å·¥ç¨‹æ¨¡æ¿ï¼š

### âœ” **bag æ–‡ä»¶ â†’ å›¾åƒ + IMU åŒæ­¥åçš„è¾“å‡ºç¨‹åºï¼ˆC++ï¼‰**

### âœ” **algorithm pipeline ä¸­åŒæ­¥å¤šä¸ª topic çš„æ¨¡å—ï¼ˆC++ ç±»å°è£…ï¼‰**

### âœ” **è‡ªåŠ¨åŒæ­¥å¹¶å¯¼å‡º csv çš„å·¥å…·**

ä½ è¯´ä¸€ä¸‹ä½ æƒ³åšå“ªä¸€ç§ï¼Œæˆ‘ç»™ä½ å®Œæ•´ä»£ç ç»“æ„ã€‚
