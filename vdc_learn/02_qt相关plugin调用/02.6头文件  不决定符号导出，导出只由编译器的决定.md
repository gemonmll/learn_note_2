下面我用**最容易理解**的方式解释什么是 **编译期 symbol visibility（符号可见性）**，为什么存在它，以及举一个非常直观的例子（含 `nm` 结果）。

---

# 🧩 **1. 什么是“符号” (symbol)？**

**符号 = 程序中可被链接器识别的名字**

例如：

* 函数名：`add`
* 类方法名：`A::foo`
* 全局变量：`g_value`
* 虚函数表：`vtable for A`

编译器把这些符号放到 ELF（.o、.so）文件的 symbol table 中。

---

# 🔥 **2. symbol visibility = 决定这个符号是否对外可见（能否被别的库使用）**

就像“门是否开着”：

| visibility  | 含义             |
| ----------- | -------------- |
| **default** | 向外开放（可以被其他库使用） |
| **hidden**  | 对外隐藏，只在本模块内部可见 |

默认规则：

* Linux/GCC 默认：**所有符号都是 default**
* Windows 默认：**所有符号都是 hidden，必须用 dllexport 才能导出**

---

# 🔧 **3. 常见控制 visibility 的方式**

### ✔ Linux/GCC/Clang

内建属性：

```cpp
__attribute__((visibility("default")))
__attribute__((visibility("hidden")))
```

也可以用编译选项 **改变全局默认行为**：

```bash
-fvisibility=hidden
```

---

# 🧱 4. 一个简单例子（最直观看到 visibility 的效果）

### example.h

```cpp
#pragma once

int add(int a, int b);          // 想让外部使用
int internal(int a, int b);     // 想隐藏
```

### example.cpp

```cpp
#include "example.h"

__attribute__((visibility("default")))
int add(int a, int b)
{
    return a + b;
}

__attribute__((visibility("hidden")))
int internal(int a, int b)
{
    return a - b;
}
```

### 编译成动态库：

```bash
g++ -shared -fPIC example.cpp -o libexample.so
```

---

# 🔍 5. 用 nm 查看导出的符号

```bash
nm -D libexample.so
```

输出：

```
0000000000001130 T add
```

你会发现：

* **add** 出现了（因为 visibility=default）
* **internal 完全不在 .so 中** （因为 visibility=hidden）

也就是说：

> **internal 函数头文件里面写了，但不会出现在 so 中。
> 也无法被外部程序链接或调用。**

这就是 visibility 的意义。

---

# 🧠 关键点总结（非常重要）

### **symbol visibility 是编译器决定符号是否对外暴露的机制。**

它和 .h 文件没有关系：

* .h 文件只告诉“别人能看到哪些声明”
* visibility 才决定“别人最终能否链接这些符号”

---

# 🎯 **6. 再举一个类的例子（更贴近你实际 Qt 插件的场景）**

example.h：

```cpp
class __attribute__((visibility("default"))) Foo
{
public:
    void hello();
};

class Bar
{
public:
    void hi();
};
```

example.cpp：

```cpp
#include "example.h"
void Foo::hello() {}
void Bar::hi() {}
```

### nm -D libexample.so：

```
vtable for Foo
Foo::hello
Foo::Foo
Foo::~Foo
```

没有：

```
Bar::hi
Bar::~Bar
Bar::Bar
```

因为 Bar 类、函数默认为 hidden，不导出。

---

# 📦 **7. 为什么 Qt 要用 Q_DECL_EXPORT / Q_DECL_IMPORT？**

因为不同系统默认 visibility 不一样：

| 系统      | 默认行为                    |
| ------- | ----------------------- |
| Linux   | 默认导出所有符号（容易泄漏）          |
| macOS   | 类似 Linux                |
| Windows | 默认不导出任何符号（必须 dllexport） |

Qt 通过：

```cpp
Q_DECL_EXPORT == __attribute__((visibility("default"))) 或 __declspec(dllexport)
Q_DECL_IMPORT == __declspec(dllimport)
```

实现跨平台统一。

---

# 🧨 一句话总结

> **编译期 symbol visibility 是编译器决定哪些符号导出到 .so，哪些保持隐藏的机制。
> 头文件是否写了某个类或函数，与是否导出无关。**

---

# 📌 需要我扩展一下吗？

我可以继续帮你：

* 一个带工厂函数 `CreatePlugin()` 的完整插件例子
* 如何使用 `-fvisibility=hidden` 优化插件 system
* 如何查看一个 Qt 插件实际导出的符号
* Linux / Windows / macOS visibility 差异详解

你要看哪一个？
