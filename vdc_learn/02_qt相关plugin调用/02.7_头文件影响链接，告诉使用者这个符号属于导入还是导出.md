这是一个 **非常好的问题**，也是很多人第一次接触动态库导出宏时最难理解的点。

下面我会讲得非常清楚：

# 🧨 **为什么导出宏（Q_DECL_EXPORT）必须写在头文件，而不是 cpp？**

## 📌 **简短回答：因为“导出”必须对使用这个头文件的人透明。它影响链接，不影响实现。**

如果写在 cpp 中：

* 外部使用者 **看不到** 这个符号是导出的
* 链接器也无法知道 header 中的类/函数是有导出版本的
* 调用者无法正确生成对该符号的引用（exc symbol binding）
* Windows 上甚至根本无法导入符号

必须在头文件写，是因为 **导出与导入需要作用在声明上，而不是定义上**。

下面我用例子直观解释。

---

# 🎯 **1. 导出/导入行为发生在“使用者编译时”**

### 当 DLL 编译时，需要：

```
__declspec(dllexport)
```

导出符号。

### 当主程序编译时，需要：

```
__declspec(dllimport)
```

导入这些符号。

也就是说：

> **同一个头文件，在不同项目中需要展开成不同的导出/导入修饰词。**

---

# 🧱 **2. 同一个头文件，两种角色**

比如：

```cpp
class MY_EXPORT Foo
{
public:
    void hello();
};
```

出现两种情况：

### 情况 A：编译动态库 Foo.dll 时

```cpp
#define MY_EXPORT __declspec(dllexport)
```

变成：

```cpp
class __declspec(dllexport) Foo
```

### 情况 B：编译使用者（主程序）时

```cpp
#define MY_EXPORT __declspec(dllimport)
```

变成：

```cpp
class __declspec(dllimport) Foo
```

⭐ 这样调用者才能正确链接到 DLL 中符号。

---

# ❌ 如果你把导出写到 cpp：

example.cpp：

```cpp
__declspec(dllexport)
void Foo::hello() {}
```

头文件：

```cpp
class Foo { void hello(); };
```

问题来了：

### ➤ 使用者编译时，看到的头文件是：

```
void Foo::hello();
```

没有导入修饰：

```
__declspec(dllimport)
```

这样主程序编译器不知道这是从 DLL 里来的函数。

结果就是：

* Windows：外部永远不能成功链接到这个函数
* Linux：ABI 符号信息不正确
* Qt 插件系统根本无法工作

所以：

# 🚫 **导出写在 cpp 会导致使用者无法导入**

---

# 📌 **3. 关键点：编译器需要在“使用头文件的时候”知道符号是 export 还是 import**

### 因为：

* C++ 类 vtable 的布局可能不同
* symbol binding 需要 import/export 信息
* Windows 需要不同指令来导入/导出符号
* inline 方法必须在头文件中修饰
* 模板类必须在头文件中全部展开，无法在 cpp 中定义 export

---

# 🔥 **4. 一个直观例子（失败版）**

假设你这样做：

## foo.h

```cpp
class Foo { public: void hello(); };
```

## foo.cpp

```cpp
__declspec(dllexport)
void Foo::hello() {}
```

## main.cpp（使用者）

```cpp
#include "foo.h"

int main() {
    Foo f;
    f.hello();
}
```

编译 main 会报错：

```
unresolved external symbol Foo::hello
```

因为头文件没有 `__declspec(dllimport)`，
使用者不知道 hello() 来自 DLL。

---

# 🧠 **5. 所以正确方式：在头文件写宏状态，让编译器决定导入或导出**

foo_global.h：

```cpp
#if defined(FOO_LIBRARY)
#    define FOO_EXPORT __declspec(dllexport)
#else
#    define FOO_EXPORT __declspec(dllimport)
#endif
```

foo.h：

```cpp
class FOO_EXPORT Foo
{
public:
    void hello();
};
```

让编译 DLL 时设置：

```
-D FOO_LIBRARY
```

就导出符号。

让编译主程序时：

```
不设置 FOO_LIBRARY
```

就导入符号。

---

# 🎉 最终总结（非常关键）

| 为什么不能在 cpp 里写导出？                      | 原因       |
| ------------------------------------- | -------- |
| 使用者看不到符号的导入属性                         | 链接失败     |
| Windows DLL 机制要求声明处必须注明 import/export | 必须在 .h   |
| inline / 模板函数没有 cpp                   | 只能写在 .h  |
| 类的 vtable 需要统一导出策略                    | 必须写在类声明处 |
| 同一个头文件在不同项目中要切换 import/export         | 必须用宏+头文件 |

---

# 📦 如果你愿意我可以继续：

✔ 用 nm 展示“头文件写导出 vs cpp 写导出”的差异
✔ Qt 插件系统中 Q_DECL_EXPORT 的真实用途
✔ 一个可运行的动态库 + 主程序的完整例子
✔ visibility + namespace + 模板的高级知识

你需要吗？
