好的，这篇文档是上一篇（如何*编写*可组合节点）的续篇，它教你如何**运行和管理**这些可组合节点。

核心目标是：将多个节点（组件）加载到**同一个进程**中运行，以提高效率。

这是为你准备的学习摘要：

## 1\. 什么是组件组合？

简单来说，就是启动一个“容器”进程，然后像插拔插件一样，把你的节点（现在是共享库）动态地加载进去。

## 2\. 如何发现可用的组件？

在你的工作空间中，可以用这个命令查看所有已注册、可以被加载的组件：

```bash
ros2 component types
```

它会列出所有可用的插件，格式通常是 `包名::类名`（例如 `composition::Talker`）。

## 3\. 运行组件的主要方式

有几种方法可以实现组合，最常用的是“运行时组合”。

### 方式一：运行时组合 (使用 ROS 服务) - 推荐 ⭐️

这是最灵活的方法，使用命令行工具动态加载和管理。

1.  **启动容器**：
    首先，启动一个空的组件容器进程。

    ```bash
    ros2 run rclcpp_components component_container
    ```

    这个容器启动后会等待加载组件。

2.  **查看容器**：
    你可以用 `list` 命令查看当前有哪些容器在运行。

    ```bash
    ros2 component list
    # 输出: /ComponentManager
    ```

3.  **加载组件**：
    使用 `load` 命令将你的组件加载到容器中。

    ```bash
    # 命令格式: ros2 component load <容器名> <包名> <插件类名>
    ros2 component load /ComponentManager composition composition::Talker
    ros2 component load /ComponentManager composition composition::Listener
    ```

4.  **查看已加载的组件**：
    再次使用 `list` 命令，可以看到容器里现在有哪些节点在运行。

    ```bash
    ros2 component list
    # 输出:
    # /ComponentManager
    #    1  /talker
    #    2  /listener
    ```

    这里的 `1` 和 `2` 是组件的唯一 ID，卸载时会用到。

### 方式二：使用 Launch 文件 (自动化)

这其实就是“方式一”的自动化版本，也是实际项目中**最常用**的方式。你不需要手动敲上面的命令，而是在 Python 启动文件中定义好容器和要加载的组件。

这在上一篇文档的末尾已经讲过了，这里复习一下关键代码：

```python
from launch_ros.actions import ComposableNodeContainer
from launch_ros.descriptions import ComposableNode

# ...
container = ComposableNodeContainer(
    name='my_container',
    namespace='',
    package='rclcpp_components',      # 容器所在的包
    executable='component_container', # 容器的可执行文件
    composable_node_descriptions=[
        # 列表里是所有要加载的组件
        ComposableNode(
            package='composition',
            plugin='composition::Talker', # 插件类名
            name='talker'
        ),
        ComposableNode(
            package='composition',
            plugin='composition::Listener',
            name='listener',
            # 开启进程内通信！
            extra_arguments=[{'use_intra_process_comms': True}] 
        )
    ]
)
ld.add_action(container)
```

### 方式三：编译时组合 (硬编码)

  * **做法**：你不需要 `component_container`。而是自己写一个带 `main` 函数的新 C++ 文件，在这个文件里 `include` 你所有组件的头文件，并在 `main` 函数中手动 `new` (创建) 它们的对象实例，然后把它们都添加到一个执行器 (Executor) 里。
  * **优点**：简单直接，不需要 ROS 的加载机制。
  * **缺点**：**不灵活**。每次增删节点，你都必须修改这个 `main` 文件并重新编译。
  * **注意**：用这种方式启动的节点**不会**显示在 `ros2 component list` 中。

### 方式四：运行时组合 (使用 dlopen)

  * **做法**：运行一个特殊的 `dlopen_composition` 容器，并把组件库的 `.so` 文件路径作为命令行参数传给它。
  * **缺点**：比方式一更底层，也**不灵活**。
  * **注意**：同样**不会**显示在 `ros2 component list` 中。

-----

## 4\. 高级主题（非常重要）

### 容器的类型 (Executors)

`rclcpp_components` 提供了几种不同的容器，主要区别在于它们如何处理多线程：

  * `component_container` (默认)：
    使用一个**单线程执行器** (`SingleThreadedExecutor`)。所有加载进来的组件都在这一个线程里运行。
  * `component_container_mt` (常用)：
    使用一个**多线程执行器** (`MultiThreadedExecutor`)。你可以通过参数指定线程数（例如 `-p thread_num:=4`）。所有组件共享这个线程池。
  * `component_container_isolated`：
    **为每个加载的组件都创建一个独立的多线程执行器**。这提供了最强的隔离性，但资源消耗也最大。

### 卸载组件

你可以使用 `unload` 命令，通过组件的 ID（从 `list` 命令中获取）来停止并卸载它：

```bash
# 卸载 ID 为 1 和 2 的组件
ros2 component unload /ComponentManager 1 2
```

### 传递参数 (Parameters)

在 `load` 时，可以使用 `-p` 来设置节点的 ROS 参数：

```bash
ros2 component load /ComponentManager image_tools image_tools::Cam2Image -p burger_mode:=true
```

### 传递额外参数 (Extra Arguments)

这是**最重要**的高级功能之一。你可以使用 `-e` 来传递特殊的构造选项。

  * `use_intra_process_comms:=true`：
    **开启进程内通信 (Intra-Process Comms)**。这是实现高效通信的关键。在 Launch 文件中，这就是 `extra_arguments` 字典的作用。
  * `forward_global_arguments:=false`：
    是否将全局参数（如 `__ns`）转发给组件。

### 非节点 (Non-Node) 组件

你的组件类不一定非要继承自 `rclcpp::Node`。它可以是一个普通类，只要它满足两个条件：

1.  构造函数接受 `const rclcpp::NodeOptions&`。
2.  实现一个 `get_node_base_interface()` 方法。

这通常用于实现一些“类节点”的功能，比如你在类内部持有一个 `Node` 成员，并返回它的 `NodeBaseInterface`。