好的，我们来详细学习这篇高级教程：**《在你的 C++ 节点中录制 Bag》 (Recording A Bag From Your Own Node (C++))**。

这篇教程非常实用。通常我们使用 `ros2 bag record` 命令行工具来录制 rosbag，但这是一个**外部**进程。本教程的目标是：**在你的 C++ 节点内部，通过代码来编程实现录制 rosbag**。

这为什么很重要？因为它允许你实现更高级的逻辑，例如：

  * **触发式录制**: 收到某个服务调用或特定消息后才开始录制。
  * **事件驱动录制**: 当检测到某个（例如错误）状态时自动开始录制，问题解决后自动停止。
  * **自定义文件名**: 根据程序逻辑（如时间戳、机器人 ID）动态生成 bag 文件的存储路径。
  * **应用内“黑匣子”**: 将录制功能作为机器人主程序的一部分，而不是依赖外部脚本。

-----

### 核心机制：`rosbag2_cpp::Writer`

实现这一切的核心是 `rosbag2_cpp` 这个库。你不需要手动去写 `sqlite3` 数据库，`rosbag2_cpp` 已经为我们封装好了一切。

关键的类是 `rosbag2_cpp::Writer`。

**核心步骤如下：**

1.  **创建 `Writer` 实例**: `auto writer_ = std::make_unique<rosbag2_cpp::Writer>();`
2.  **配置存储选项 (`StorageOptions`)**: 设置 bag 文件的路径（`uri`）和存储插件（`storage_id`，通常是 `sqlite3`）。
3.  **配置转换器选项 (`ConverterOptions`)**: 设置序列化格式（通常输入输出都是 `cdr`）。
4.  **打开 Bag 文件**: `writer_->open(...)`。
5.  **(关键) 订阅 Topic**: 创建一个标准的 `rclcpp::Subscription` 来订阅你想录制的数据。
6.  **(关键) 注册 Topic**: 告诉 `Writer` 你将要写入哪一个 Topic，包括它的名称和类型。`writer_->create_topic(...)`。
7.  **在订阅的回调中写入数据**:
      * 从订阅中获取消息。
      * 创建一个 `rosbag2_storage::SerializedBagMessage` 对象。
      * **手动设置时间戳** (`time_stamp`)。
      * 将消息的**序列化数据** (`serialized_data`) 复制到 bag 消息中。
      * 调用 `writer_->write(bag_message)` 将消息写入磁盘。
8.  **(关键) RAII 资源管理**: 当 `writer_` 对象被销毁时（例如节点关闭，`unique_ptr` 自动释放），它的析构函数会自动调用 `close()` 来关闭文件，确保数据被完整写入。

-----

### 源码精炼 (1): 依赖配置

首先，你必须告诉 ROS 2 你的包依赖 `rosbag2_cpp`。

#### `package.xml`

```xml
<?xml version="1.0"?>
<package format="3">
  <name>rosbag2_examples_cpp</name>
  <version>0.0.0</version>
  <description>C++ rosbag2 examples</description>
  <maintainer email="user@example.com">User</maintainer>
  <license>Apache 2.0</license>

  <build_depend>rclcpp</build_depend>
  <build_depend>std_msgs</build_depend>

  <build_depend>rosbag2_cpp</build_depend>

  <exec_depend>rclcpp</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>rosbag2_cpp</exec_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

#### `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.8)
project(rosbag2_examples_cpp)

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
# 关键：找到 rosbag2_cpp 包
find_package(rosbag2_cpp REQUIRED)

# 教程中包含两个节点：
# 1. 一个简单的数据发布者
add_executable(data_generator_node src/data_generator_node.cpp)
ament_target_dependencies(data_generator_node rclcpp std_msgs)

# 2. 我们的录制节点
add_executable(simple_bag_recorder src/simple_bag_recorder.cpp)
ament_target_dependencies(
  simple_bag_recorder 
  rclcpp 
  std_msgs 
  rosbag2_cpp  # 关键：链接到 rosbag2_cpp
)

install(TARGETS
  data_generator_node
  simple_bag_recorder
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

-----

### 源码精炼 (2): 数据发布者 (`data_generator_node.cpp`)

这只是一个标准的 "talker" 节点，用于产生数据。我们必须有数据才能录制。

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;

/* 这是一个简单的发布者，每 500ms 发送一条 "Hello World" 消息 */
class DataGenerator : public rclcpp::Node
{
public:
  DataGenerator() : Node("data_generator")
  {
    publisher_ = this->create_publisher<std_msgs::msg::String>("hello", 10);
    timer_ = this->create_wall_timer(
      500ms, std::bind(&DataGenerator::timer_callback, this));
  }

private:
  void timer_callback()
  {
    auto message = std_msgs::msg::String();
    message.data = "Hello World: " + std::to_string(count_++);
    RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
    publisher_->publish(message);
  }
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  size_t count_ = 0;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<DataGenerator>());
  rclcpp::shutdown();
  return 0;
}
```

-----

### 源码精炼 (3): 录制节点 (`simple_bag_recorder.cpp`)

这是本教程的**核心代码**。请注意订阅时的消息类型和回调函数中的操作。

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

// 关键的 rosbag2 C++ API 头文件
#include "rosbag2_cpp/writer.hpp"
#include "rosbag2_cpp/storage_options.hpp"
#include "rosbag2_cpp/converter_options.hpp"

// (注意：教程原文中还包含 rclcpp/serialization.hpp，
// 但在这个例子中，如果订阅 SerializedMessage，则需要它)

using std::placeholders::_1;

class SimpleBagRecorder : public rclcpp::Node
{
public:
  SimpleBagRecorder() : Node("simple_bag_recorder")
  {
    // 1. 创建 Writer 实例 (使用 unique_ptr 自动管理生命周期)
    writer_ = std::make_unique<rosbag2_cpp::Writer>();

    // 2. 配置存储选项
    rosbag2_cpp::StorageOptions storage_options;
    storage_options.uri = "my_bag";       // bag 文件的目录名
    storage_options.storage_id = "sqlite3"; // 存储插件
    
    // 3. 配置转换器选项
    rosbag2_cpp::ConverterOptions converter_options;
    converter_options.input_serialization_format = "cdr";
    converter_options.output_serialization_format = "cdr";

    // 4. 打开 Bag 文件
    // 这会在当前工作目录下创建一个 "my_bag" 文件夹
    writer_->open(storage_options, converter_options);

    // 5. 注册 Topic (告诉 Bag 文件：我要写入这个 Topic)
    rosbag2_storage::TopicMetadata topic_metadata;
    topic_metadata.name = "hello"; // 必须与订阅的 Topic 一致
    topic_metadata.type = "std_msgs/msg/String"; // 必须与 Topic 类型一致
    topic_metadata.serialization_format = "cdr"; // 与上面一致
    writer_->create_topic(topic_metadata);

    // 6. 订阅 Topic

    /*
     * [!!! 教程中的关键性能点 !!!]
     * 教程代码中订阅的是 rclcpp::SerializedMessage。
     * 为什么？
     * * 方式 A (低效): 订阅 std_msgs::msg::String
     * ROS 中间件接收 -> 反序列化 (二进制 -> C++ String 对象) ->
     * -> 你的回调函数 -> 序列化 (C++ String 对象 -> 二进制) -> 写入 Bag
     *
     * 方式 B (高效): 订阅 rclcpp::SerializedMessage
     * ROS 中间件接收 -> (保持序列化) ->
     * -> 你的回调函数 -> (直接) -> 写入 Bag
     *
     * 方式 B 避免了一次不必要的“反序列化-再序列化”开销，
     * 这对于高速录制（如激光雷达、相机）至关重要。
     */
    subscription_ = this->create_subscription<rclcpp::SerializedMessage>(
      "hello", 10, std::bind(&SimpleBagRecorder::topic_callback, this, _1));
    
    RCLCPP_INFO(this->get_logger(), "Node started, recording to 'my_bag'...");
  }

  // 析构函数：当节点关闭时，writer_ 会被自动销毁。
  // unique_ptr 会调用 Writer 的析构函数，
  // 该析构函数会负责调用 close()，将所有数据刷入磁盘并关闭文件。
  ~SimpleBagRecorder()
  {
    // writer_->close(); // 即使不显式调用，RAII 也会处理
  }

private:
  // 7. 回调函数：处理 SerializedMessage
  void topic_callback(std::shared_ptr<rclcpp::SerializedMessage> msg)
  {
    RCLCPP_INFO(this->get_logger(), "Writing message to bag");

    // a. 创建一个 rosbag 消息容器
    auto bag_message = std::make_shared<rosbag2_storage::SerializedBagMessage>();

    // b. 复制序列化后的数据
    // 注意：我们直接从 SerializedMessage 中取出 rcl_serialized_message
    bag_message->serialized_data = msg->get_rcl_serialized_message().buffer;
    
    // c. 必须手动设置 Topic 名称
    bag_message->topic_name = "hello"; // 或者用 subscription_->get_topic_name()

    // d. 必须手动设置时间戳 (使用录制器的时间)
    bag_message->time_stamp = this->get_clock()->now().nanoseconds();

    // e. 写入 Bag！
    writer_->write(bag_message);
  }

  rclcpp::Subscription<rclcpp::SerializedMessage>::SharedPtr subscription_;
  std::unique_ptr<rosbag2_cpp::Writer> writer_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<SimpleBagRecorder>());
  rclcpp::shutdown();
  return 0;
}
```

-----

### 编译和运行

1.  **编译**:

    ```bash
    cd ~/ros2_ws
    colcon build --packages-select rosbag2_examples_cpp
    ```

2.  **Source 环境**:

    ```bash
    source install/setup.bash
    ```

3.  **运行** (需要两个终端):

      * **终端 1 (启动数据发布者)**:

        ```bash
        ros2 run rosbag2_examples_cpp data_generator_node
        ```

        *你会看到 "Publishing: 'Hello World: ...'" 的日志*

      * **终端 2 (启动录制节点)**:

        ```bash
        ros2 run rosbag2_examples_cpp simple_bag_recorder
        ```

        *你会看到 "Writing message to bag" 的日志*

4.  **验证**:

      * 在**终端 2** 中按 `Ctrl+C` 停止录制。
      * 查看你的工作目录（`~/ros2_ws` 或你运行命令的地方）：
        ```bash
        ls
        ```
        *你会看到一个新目录 `my_bag` 被创建了。*
      * 使用 `ros2 bag info` 检查 bag 文件的内容：
        ```bash
        ros2 bag info my_bag
        ```
      * 你应该能看到类似这样的输出，证明录制成功：
        ```
        Files:             my_bag.db3
        Bag size:          ...
        Storage id:        sqlite3
        Duration:          ...
        Start:             ...
        End:               ...
        Messages:          ...
        Topics with Type:
          - topic: /hello
            type: std_msgs/msg/String
            count: ...
        ```

### 总结

这篇教程通过 `rosbag2_cpp::Writer` 类，为你打开了在 C++ 节点中实现复杂录制逻辑的大门。

最重要的技术点是：

1.  **使用 `rosbag2_cpp::Writer`** 来处理所有文件 I/O。
2.  **订阅 `rclcpp::SerializedMessage`** (而不是具体的消息类型) 来实现最高效的录制，避免不必要的序列化/反序列化开销。
3.  **手动填充 `SerializedBagMessage`**，特别是 `time_stamp` 和 `topic_name`。
4.  **利用 RAII (`std::unique_ptr`)** 来确保节点关闭时，bag 文件能被正确地关闭和保存。