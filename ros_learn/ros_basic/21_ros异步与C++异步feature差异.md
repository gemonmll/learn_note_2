ä½ é—®åˆ°è¿™ä¸ªç‚¹éå¸¸ç²¾å‡† ğŸ¯â€”â€”è¿™æ­£æ˜¯ **ROS 2 çš„å¼‚æ­¥æœºåˆ¶** å’Œ **æ ‡å‡† C++ å¼‚æ­¥æœºåˆ¶ï¼ˆ`std::future`ï¼‰** çš„**æ ¹æœ¬å·®å¼‚**æ‰€åœ¨ã€‚
æˆ‘ä»¬ä¸€æ­¥æ­¥è§£é‡Šæ¸…æ¥šä¸ºä»€ä¹ˆ **â€œåœ¨ ROS 2 ä¸­å¿…é¡» `spin()` æ‰èƒ½è®© future å®Œæˆâ€** ğŸ‘‡

---

## ğŸ§© 1ï¸âƒ£ é¦–å…ˆï¼šC++ çš„ `std::future` æ˜¯ä»€ä¹ˆæ ·çš„

åœ¨ **çº¯ C++ æ ‡å‡†åº“** ä¸­ï¼š

```cpp
auto fut = std::async([] { return 42; });
int val = fut.get();   // âœ… ä¸€å®šèƒ½å–åˆ°ç»“æœ
```

ä¸ºä»€ä¹ˆèƒ½ç›´æ¥ `get()`ï¼Ÿ
å› ä¸ºæ ‡å‡†åº“çš„ `std::async` èƒŒåï¼š

* ä¼šè‡ªåŠ¨å¼€ä¸€ä¸ª **çº¿ç¨‹**ï¼›
* è¿™ä¸ªçº¿ç¨‹è‡ªåŠ¨æ‰§è¡Œé‚£ä¸ª lambdaï¼›
* æ‰§è¡Œå®Œåè‡ªåŠ¨è°ƒç”¨ `promise.set_value()`ï¼›
* æ‰€ä»¥ `future.get()` èƒ½æ‹¿åˆ°ç»“æœï¼ˆå¹¶é˜»å¡ç­‰å¾…ï¼‰ã€‚

ğŸ‘‰ ä¹Ÿå°±æ˜¯è¯´ï¼š
**æ ‡å‡†åº“ future çš„æ‰§è¡Œæ˜¯ç”± C++ runtime è‡ªåŠ¨è°ƒåº¦çš„ï¼ˆçº¿ç¨‹è‡ªåŠ¨è·‘èµ·æ¥ï¼‰ã€‚**

---

## ğŸš€ 2ï¸âƒ£ è€Œåœ¨ ROS 2 é‡Œï¼Œæƒ…å†µå®Œå…¨ä¸åŒ

ä½ å‘å‡ºçš„è¿™ä¸ªè¯·æ±‚ï¼š

```cpp
auto future = client->async_send_request(request);
```

è¿™é‡Œçš„ `async_send_request()` è™½ç„¶å« *async*ï¼Œ
ä½†å®ƒå¹¶ **æ²¡æœ‰åˆ›å»ºçº¿ç¨‹æˆ–åå°ä»»åŠ¡**ã€‚

ç›¸åï¼Œå®ƒåªæ˜¯ï¼š

* æ„é€ äº†ä¸€ä¸ª `std::shared_future`ï¼›
* æŠŠè¯·æ±‚æ‰“åŒ…åäº¤ç»™ ROS çš„é€šä¿¡å±‚ï¼ˆrmw å±‚ï¼‰ï¼›
* ç­‰å¾… executorï¼ˆæ‰§è¡Œå™¨ï¼‰å»è½®è¯¢ç½‘ç»œäº‹ä»¶å¹¶è°ƒç”¨å›è°ƒã€‚

---

## ğŸ§  3ï¸âƒ£ æ¢å¥è¯è¯´ï¼š

ğŸ”¹ åœ¨ **ROS 2** é‡Œï¼š

* ä½ çš„ **future** å¹¶ä¸ä¼šè‡ªåŠ¨å®Œæˆï¼›
* åªæœ‰å½“ **executor** è¿è¡Œæ—¶ï¼ˆä¾‹å¦‚ `rclcpp::spin()`ï¼‰ï¼›
* å®ƒæ‰ä¼šï¼š

  1. ä» DDS/ä¸­é—´ä»¶é‡Œè¯»å–â€œæœ‰å“åº”æ¥äº†â€ï¼›
  2. è°ƒç”¨å†…éƒ¨å›è°ƒï¼›
  3. æŠŠå“åº”å†™å…¥åˆ° `promise.set_value()`ï¼›
  4. æœ€ç»ˆè®© `future` çŠ¶æ€å˜ä¸º readyã€‚

ğŸ‘‰ å¦‚æœ executor æ²¡è¿è¡Œï¼Œé‚£ promise æ°¸è¿œä¸ä¼š setã€‚
â†’ future æ°¸è¿œå¤„äºâ€œç­‰å¾…ä¸­â€çŠ¶æ€ã€‚
â†’ `.get()` æ°¸è¿œé˜»å¡ã€‚

---

## ğŸ”„ 4ï¸âƒ£ æ‰€ä»¥éœ€è¦ `spin()` æˆ– `spin_until_future_complete()`

`rclcpp::spin(node)` æˆ– `spin_until_future_complete(node, future)` çš„ä½œç”¨ï¼š

> **é©±åŠ¨ ROS çš„äº‹ä»¶å¾ªç¯ï¼ˆexecutorï¼‰**
> å»æ£€æŸ¥è®¢é˜…ã€å›è°ƒã€æœåŠ¡å“åº”ç­‰å„ç§äº‹ä»¶ã€‚

æ²¡æœ‰ `spin`ï¼Œå°±ç­‰äºï¼š

* æ²¡äººå¸®ä½ å¤„ç† socketï¼›
* æ²¡äººæŠŠ DDS ç½‘ç»œåŒ…è§£å‡ºæ¥ï¼›
* æ²¡äººè°ƒç”¨å†…éƒ¨ `promise.set_value()`ï¼›
* future è‡ªç„¶æ°¸è¿œä¸ä¼šå®Œæˆã€‚

---

## âš™ï¸ 5ï¸âƒ£ å¯¹æ¯”æ€»ç»“ä¸€ä¸‹ï¼š

| ç‰¹æ€§                        | æ ‡å‡† C++ `std::async` | ROS 2 `async_send_request` |
| ------------------------- | ------------------- | -------------------------- |
| æ˜¯å¦è‡ªåŠ¨æ‰§è¡Œ                    | âœ… æ˜¯ï¼ˆè‡ªåŠ¨åˆ›å»ºçº¿ç¨‹ï¼‰         | âŒ å¦ï¼ˆç­‰å¾… executor è¿è¡Œï¼‰        |
| è°è§¦å‘ `promise.set_value()` | C++ runtime         | ROS executor               |
| `future.get()` æ˜¯å¦èƒ½ç›´æ¥å¾—åˆ°ç»“æœ  | âœ… å¯ä»¥ï¼ˆä¼šé˜»å¡ç­‰å¾…çº¿ç¨‹ï¼‰       | âŒ ä¸è¡Œï¼ˆé™¤é spin è¿è¡Œï¼‰           |
| èƒŒåæœºåˆ¶                      | C++ çº¿ç¨‹æ± æˆ–ç³»ç»Ÿçº¿ç¨‹        | ROS2 DDS é€šä¿¡ + callback     |

---

## ğŸ’¡ 6ï¸âƒ£ æ¢ä¸ªæ›´å½¢è±¡çš„æ¯”å–»

* **C++ çš„ future**
  â†’ ä½ è¯·äº†ä¸€ä¸ªå¤–å–å‘˜ï¼ˆasyncï¼‰å»é€é¤ï¼›
  ä»–è‡ªå·±éª‘è½¦ã€è‡ªå·±è·‘ï¼Œé€åˆ°äº†ä½ å®¶é—¨å£ã€‚

* **ROS 2 çš„ future**
  â†’ ä½ è¯·äº†ä¸€ä¸ªâ€œå…¬å¸è°ƒåº¦ä¸­å¿ƒâ€é€å¤–å–ï¼›
  ä½†åªæœ‰å½“è°ƒåº¦ä¸­å¿ƒï¼ˆexecutorï¼‰åœ¨è¿è¡Œï¼Œ
  å¤–å–å‘˜æ‰ä¼šè¢«æ´¾å‡ºã€‚
  å¦‚æœè°ƒåº¦ä¸­å¿ƒæš‚åœï¼ˆæ²¡ spinï¼‰ï¼Œæ²¡äººæ´¾é€ã€‚

---

## âœ… 7ï¸âƒ£ ç»“è®ºæ€»ç»“ä¸€å¥è¯ï¼š

> åœ¨ ROS 2 ä¸­ï¼Œ`async_send_request()` è¿”å›çš„ future åªæ˜¯ä¸€ä¸ªâ€œå ä½ç¬¦â€ï¼Œ
> **å¿…é¡»é€šè¿‡ executorï¼ˆä¾‹å¦‚ `spin()`ï¼‰é©±åŠ¨äº‹ä»¶å¾ªç¯**ï¼Œ
> è®© ROS é€šä¿¡å±‚æŠŠå“åº”å¡«å…¥ futureï¼Œ
> å¦åˆ™ `.get()` æ°¸è¿œä¸ä¼šè¿”å›ã€‚

---

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ ç”»ä¸€ä¸ªå¯¹æ¯”æµç¨‹å›¾ï¼š
**ã€Œæ ‡å‡† C++ future æµç¨‹ã€ vs ã€ŒROS 2 future æµç¨‹ã€**ï¼Œ
çœ‹å›¾ä¼šæ›´æ¸…æ¥š ROS executor åœ¨å“ªä¸€æ­¥ä»‹å…¥ã€‚

---
# ä»£ç ä¸­çš„ç–‘é—®
---

éå¸¸æ£’çš„é—®é¢˜ ğŸ’¡ï¼
ä½ æŠ“ä½äº† ROS2 client è°ƒç”¨é‡Œæœ€å®¹æ˜“â€œæ··æ·†â€çš„ä¸€ç‚¹ â€”â€”
`async_send_request()` + `spin_until_future_complete()` + `future.get()` çš„å…³ç³»ã€‚
æˆ‘ä»¬ä¸€æ­¥æ­¥æ¥æŠŠè¿™ä¸‰è€…çš„åŒºåˆ«å’Œé€»è¾‘**å®Œå…¨æ‹†å¼€è®²æ¸…æ¥š** ğŸ‘‡

---

## ğŸ§© 1ï¸âƒ£ æ•´ä½“é€»è¾‘é¡ºåº

ä½ çš„è¿™ä¸‰è¡Œä»£ç é€»è¾‘å¦‚ä¸‹ï¼š

```cpp
auto result_future = client->async_send_request(request);     // å¼‚æ­¥å‘è¯·æ±‚ï¼ˆè¿”å›ä¸€ä¸ª futureï¼‰
rclcpp::spin_until_future_complete(node, result_future);      // ä¸»åŠ¨è½®è¯¢ç›´åˆ°æ”¶åˆ°å“åº”
auto result = result_future.get();                            // å–å‡ºå“åº”å†…å®¹
```

è¡¨é¢ä¸Šçœ‹èµ·æ¥ `spin_until_future_complete()` å’Œ `future.get()` éƒ½æ˜¯â€œç­‰å¾…ç»“æœâ€ï¼Œ
ä½†å…¶å®è¿™ä¸¤ä¸ªå‡½æ•°**ä½œç”¨å®Œå…¨ä¸åŒ**ï¼š

---

## ğŸ” 2ï¸âƒ£ å…³é”®åŒºåˆ«ï¼šè°åœ¨â€œå¤„ç†äº‹ä»¶â€ï¼Œè°åœ¨â€œå–å€¼â€

| å‡½æ•°                             | æ˜¯å¦å¤„ç† ROS äº‹ä»¶ | æ˜¯å¦é˜»å¡               | æ˜¯å¦å–å€¼     |
| ------------------------------ | ----------- | ------------------ | -------- |
| `async_send_request()`         | âŒ å¦         | âŒ å¦                | âŒ å¦      |
| `spin_until_future_complete()` | âœ… æ˜¯         | âœ… æ˜¯ï¼ˆç›´åˆ° future å®Œæˆï¼‰  | âŒ å¦      |
| `future.get()`                 | âŒ å¦         | âœ… æ˜¯ï¼ˆå¦‚æœ future æœªå®Œæˆï¼‰ | âœ… æ˜¯ï¼ˆå–å‡ºå€¼ï¼‰ |

---

### ğŸ’¡ ç”¨ç”Ÿæ´»ç±»æ¯”ï¼š

* `async_send_request()`
  â†’ ä½ å‘å‡ºä¸€ä¸ªå¤–å–è®¢å•ã€‚
  ç³»ç»Ÿå‘Šè¯‰ä½ ï¼šâ€œæˆ‘ä»¬æ­£åœ¨å‡†å¤‡ï¼Œç¨ç­‰ã€‚â€ï¼ˆè¿”å›ä¸€ä¸ªç¥¨æ® `future`ï¼‰

* `spin_until_future_complete()`
  â†’ ä½ åœ¨å¤§å…ç­‰å¾…ï¼Œåå°å·¥ä½œäººå‘˜ä¸æ–­è½®è¯¢è®¢å•çŠ¶æ€ï¼ˆæ‰§è¡Œäº‹ä»¶å¾ªç¯ï¼‰ã€‚
  ç›´åˆ°åå°å‘Šè¯‰ä½ â€œè®¢å•å·²é€è¾¾â€ã€‚

* `future.get()`
  â†’ ä½ æ‹¿ç€ç¥¨æ®å»æŸœå°é¢†å–é‚£ä»½å·²ç»é€è¾¾çš„å¤–å–ã€‚

---

## ğŸ§  3ï¸âƒ£ å†ç»†ä¸€ç‚¹ï¼ˆC++ future æœºåˆ¶ï¼‰

`async_send_request()` è¿”å›çš„å¯¹è±¡æ˜¯ï¼š

```cpp
std::shared_future<std::shared_ptr<ServiceResponse>>
```

å®ƒçš„çŠ¶æ€å¯ä»¥æ˜¯ï¼š

* **not ready**ï¼šè¯·æ±‚å‘å‡ºå»äº†ï¼Œè¿˜æ²¡å“åº”ï¼›
* **ready**ï¼šROS executor æ”¶åˆ°å“åº”å¹¶è®¾ç½®äº†å€¼ã€‚

`spin_until_future_complete()` çš„ä½œç”¨æ˜¯ï¼š

> é©±åŠ¨ ROS äº‹ä»¶å¾ªç¯ï¼Œè®©è¯¥ future çŠ¶æ€å˜ä¸º readyã€‚

ç­‰ `spin_until_future_complete()` è¿”å›åï¼š

* future å·²ç»æ˜¯ ready çŠ¶æ€ï¼›
* æ‰€ä»¥ `future.get()` ä¸ä¼šå†é˜»å¡ï¼›
* å®ƒåªæ˜¯â€œå–å€¼â€æ“ä½œã€‚

---

## âš™ï¸ 4ï¸âƒ£ å¦‚æœä½ çœç•¥ `spin_until_future_complete()` ä¼šæ€æ ·ï¼Ÿ

æ¯”å¦‚è¿™æ ·ï¼š

```cpp
auto future = client->async_send_request(req);
auto result = future.get();   // âŒ å¡æ­»ï¼
```

â†’ å› ä¸ºæ²¡æœ‰ executor é©±åŠ¨ï¼Œfuture æ°¸è¿œä¸ä¼šå˜ readyã€‚

C++ çš„ future æœºåˆ¶åªæ˜¯ç­‰å¾…å€¼è¢« setï¼Œ
ä½†**å®ƒå¹¶ä¸ä¼šè‡ªå·±è§¦å‘ ROS å›è°ƒæˆ–ç½‘ç»œäº‹ä»¶**ã€‚

---

## ğŸ§© 5ï¸âƒ£ é‚£ä¸ºä»€ä¹ˆ `get()` è¿˜è¦å†™ï¼Ÿ

å› ä¸º `spin_until_future_complete()` çš„è¿”å›å€¼åªæ˜¯å‘Šè¯‰ä½ ï¼š

> â€œfuture å·²ç»å®Œæˆï¼ˆæˆ–è¶…æ—¶ã€æˆ–è¢«ä¸­æ–­ï¼‰ã€‚â€

å®ƒ**ä¸ä¼šç›´æ¥è¿”å›å“åº”æ•°æ®æœ¬èº«**ã€‚
å“åº”æ•°æ®ä»ç„¶å­˜æ”¾åœ¨ `result_future` å¯¹è±¡é‡Œï¼Œéœ€è¦ `.get()` æ‰èƒ½å–å‡ºã€‚

è¿™å°±åƒï¼š

```cpp
if (è®¢å•çŠ¶æ€ == æˆåŠŸ)
    æ‹¿å¤–å–;
```

`spin_until_future_complete()` â‰ˆ æ£€æŸ¥â€œæ˜¯å¦é€è¾¾â€ï¼Œ
`future.get()` â‰ˆ å–å‡ºâ€œå¤–å–å†…å®¹â€ã€‚

---

## âœ… 6ï¸âƒ£ æ€»ç»“ï¼ˆç”¨ä¸€å¥è¯è®²æ¸…ï¼‰

> `async_send_request()` å‘è¯·æ±‚ï¼ˆå¼‚æ­¥å¼€å§‹ï¼‰
> `spin_until_future_complete()` è¿è¡Œ ROS å¾ªç¯ç›´åˆ°å“åº”åˆ°è¾¾
> `future.get()` ä» future é‡Œå–å‡ºå“åº”ç»“æœï¼ˆæ­¤æ—¶å·²å‡†å¤‡å¥½ï¼‰

---

## ğŸ§  Bonus: ä½ å¯ä»¥è¿™æ ·å†™ç­‰ä»·ç‰ˆæœ¬ï¼ˆæ›´æ˜¾å¼ï¼‰

```cpp
auto result_future = client->async_send_request(request);

// ç­‰å¾… future å®Œæˆï¼ˆå†…éƒ¨ spinï¼‰
rclcpp::FutureReturnCode ret =
    rclcpp::spin_until_future_complete(node, result_future);

if (ret == rclcpp::FutureReturnCode::SUCCESS) {
    // future å·² readyï¼Œä¸ä¼šé˜»å¡
    auto result = result_future.get();
    RCLCPP_INFO(node->get_logger(), "result = %ld", result->sum);
} else {
    RCLCPP_ERROR(node->get_logger(), "service call failed or timed out");
}
```

---

è¦ä¸è¦æˆ‘é¡ºå¸¦å¸®ä½ ç”»ä¸€å¼ â€œclient â†’ executor â†’ service â†’ response â†’ futureâ€çš„æµç¨‹å›¾ï¼Ÿ
é‚£æ ·ä½ ä¼šæ›´å®¹æ˜“çœ‹å‡º `spin_until_future_complete` åœ¨å“ªä¸€æ­¥â€œå”¤é†’â€äº† futureã€‚

