这份代码是一个 **ROS 2 异步客户端 (Async Client)** 的完整示例，它展示了如何用 `rclcpp` 编写一个可以同时：

1. 在主线程中与用户交互输入；
2. 在子线程中异步执行 ROS 回调（通过 executor）；
3. 异步发送服务请求，并在服务器响应时触发回调。

---

## 🧩 整体结构概览

| 组件                             | 功能                                          |
| ------------------------------ | ------------------------------------------- |
| `ClientNode`                   | 定义了一个可以异步请求 `add_two_ints` 服务的 ROS 2 节点     |
| `main()`                       | 启动 ROS，运行节点，并开一个线程让 executor spin，主线程用于用户交互 |
| `SingleThreadedExecutor`       | 在子线程中运行，用于处理服务响应和定时器回调                      |
| `std::promise` + `std::thread` | 用于安全地停止 spin 线程                             |

---

## 🧱 1️⃣ `ClientNode` 类解析

```cpp
class ClientNode : public rclcpp::Node
```

继承自 `rclcpp::Node`，表示一个 ROS 节点。

---

### 🔹 1.1 构造函数

```cpp
client_ = create_client<AddTwoInts>("add_two_ints");
```

创建一个服务客户端（`rclcpp::Client`），目标服务名为 `"add_two_ints"`。
对应的服务类型是 `example_interfaces::srv::AddTwoInts`（即输入两个整数，返回它们的和）。

---

### 🔹 1.2 定时器清理机制

```cpp
timer_ = this->create_wall_timer(5s, [this]() {
  std::vector<int64_t> pruned_requests;
  size_t n_pruned = this->client_->prune_requests_older_than(
    std::chrono::system_clock::now() - 5s, &pruned_requests);
  ...
});
```

* 每隔 5 秒执行一次 lambda。
* 调用 `prune_requests_older_than()` 清理等待时间超过 5 秒的请求。
* 如果服务端未响应，这些旧请求会被丢弃，并打印日志。

✅ **作用**：防止服务端长时间不响应导致请求堆积。

---

### 🔹 1.3 `wait_for_service_server()`

```cpp
while (!client_->wait_for_service(std::chrono::seconds(1))) {
  ...
}
```

阻塞等待服务端上线（`ros2 run examples_rclcpp_minimal_service service_main`）。
每 1 秒检查一次，直到服务可用为止。

---

### 🔹 1.4 `queue_async_request(a, b)`

核心部分 👇

```cpp
auto request = std::make_shared<AddTwoInts::Request>();
request->a = a;
request->b = b;
```

创建请求对象。

然后定义回调函数：

```cpp
auto response_received_callback =
  [logger = this->get_logger()](ServiceResponseFuture future) {
    auto request_response_pair = future.get();
    RCLCPP_INFO(
      logger,
      "Result of %" PRId64 " + %" PRId64 " is: %" PRId64,
      request_response_pair.first->a,
      request_response_pair.first->b,
      request_response_pair.second->sum);
  };
```

这里使用了 **按值捕获**（`logger = this->get_logger()`），
防止异步回调执行时 `this` 已经销毁导致悬空引用。

最后调用：

```cpp
auto result = client_->async_send_request(request, std::move(response_received_callback));
```

✅ **说明：**

* 该函数立即返回，不会阻塞；
* 响应到来时自动调用回调；
* executor 在子线程中会调度回调执行。

---

## ⚙️ 2️⃣ `main()` 主函数解析

### 🔹 2.1 初始化与创建节点

```cpp
rclcpp::init(argc, argv);
auto node = std::make_shared<ClientNode>();
```

---

### 🔹 2.2 等待服务上线

```cpp
if (!node->wait_for_service_server()) {
  return 1;
}
```

阻塞等待服务上线。

---

### 🔹 2.3 启动异步 executor 线程

```cpp
std::promise<void> stop_async_spinner;
std::thread async_spinner_thread(
  [stop_token = stop_async_spinner.get_future(), node]() {
    rclcpp::executors::SingleThreadedExecutor executor;
    executor.add_node(node);
    executor.spin_until_future_complete(stop_token);
  });
```

💡 重点：

* 创建了一个 **子线程** 来运行 ROS executor；
* 使用 `spin_until_future_complete(stop_token)` 可以在 `stop_async_spinner.set_value()` 时安全退出；
* 主线程仍然可以处理用户输入。

✅ **这就是 ROS 2 的“异步 spin 模式”**。

---

### 🔹 2.4 主线程读用户输入并发请求

```cpp
while (1) {
  auto optional_number = read_number(buffer, logger);
  ...
  node->queue_async_request(a, b);
}
```

* 用户输入两个数字；
* 调用 `queue_async_request()` 异步发出请求；
* 用户可以继续输入下一个请求，无需等待响应。

---

### 🔹 2.5 停止 executor

```cpp
stop_async_spinner.set_value();
async_spinner_thread.join();
rclcpp::shutdown();
```

主线程设置 promise 值，子线程检测到后退出 spin。

---

## ⚡ 3️⃣ Executor 与异步机制核心逻辑图

```
┌──────────────┐
│   MainThread │
│  - 读取输入   │
│  - 调用 queue │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   ClientNode │
│  - async_send_request() │
│  - 回调函数注册         │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ Executor线程 │
│  - spin_until_future_complete │
│  - 处理定时器和回调函数     │
└──────────────┘
```

---

## 🧠 4️⃣ 关键点总结

| 特性                        | 说明                                       |
| ------------------------- | ---------------------------------------- |
| 异步请求                      | 不阻塞主线程，可同时发出多个请求                         |
| 回调捕获                      | 用 `[logger = this->get_logger()]` 避免悬空引用 |
| executor 线程               | 独立线程处理回调、定时器等                            |
| promise + future          | 用于安全停止 executor                          |
| prune_requests_older_than | 清除超时请求，防止积压                              |

---

## 💬 一句话总结

> **主线程负责发请求，executor 子线程负责监听和回调。**
> 这种结构让 ROS 2 客户端可以“异步交互”，既不阻塞输入，也能及时处理响应。

---

这份代码是一个 **ROS 2 异步客户端 (Async Client)** 的完整示例，它展示了如何用 `rclcpp` 编写一个可以同时：

1. 在主线程中与用户交互输入；
2. 在子线程中异步执行 ROS 回调（通过 executor）；
3. 异步发送服务请求，并在服务器响应时触发回调。

---

## 🧩 整体结构概览

| 组件                             | 功能                                          |
| ------------------------------ | ------------------------------------------- |
| `ClientNode`                   | 定义了一个可以异步请求 `add_two_ints` 服务的 ROS 2 节点     |
| `main()`                       | 启动 ROS，运行节点，并开一个线程让 executor spin，主线程用于用户交互 |
| `SingleThreadedExecutor`       | 在子线程中运行，用于处理服务响应和定时器回调                      |
| `std::promise` + `std::thread` | 用于安全地停止 spin 线程                             |

---

## 🧱 1️⃣ `ClientNode` 类解析

```cpp
class ClientNode : public rclcpp::Node
```

继承自 `rclcpp::Node`，表示一个 ROS 节点。

---

### 🔹 1.1 构造函数

```cpp
client_ = create_client<AddTwoInts>("add_two_ints");
```

创建一个服务客户端（`rclcpp::Client`），目标服务名为 `"add_two_ints"`。
对应的服务类型是 `example_interfaces::srv::AddTwoInts`（即输入两个整数，返回它们的和）。

---

### 🔹 1.2 定时器清理机制

```cpp
timer_ = this->create_wall_timer(5s, [this]() {
  std::vector<int64_t> pruned_requests;
  size_t n_pruned = this->client_->prune_requests_older_than(
    std::chrono::system_clock::now() - 5s, &pruned_requests);
  ...
});
```

* 每隔 5 秒执行一次 lambda。
* 调用 `prune_requests_older_than()` 清理等待时间超过 5 秒的请求。
* 如果服务端未响应，这些旧请求会被丢弃，并打印日志。

✅ **作用**：防止服务端长时间不响应导致请求堆积。

---

### 🔹 1.3 `wait_for_service_server()`

```cpp
while (!client_->wait_for_service(std::chrono::seconds(1))) {
  ...
}
```

阻塞等待服务端上线（`ros2 run examples_rclcpp_minimal_service service_main`）。
每 1 秒检查一次，直到服务可用为止。

---

### 🔹 1.4 `queue_async_request(a, b)`

核心部分 👇

```cpp
auto request = std::make_shared<AddTwoInts::Request>();
request->a = a;
request->b = b;
```

创建请求对象。

然后定义回调函数：

```cpp
auto response_received_callback =
  [logger = this->get_logger()](ServiceResponseFuture future) {
    auto request_response_pair = future.get();
    RCLCPP_INFO(
      logger,
      "Result of %" PRId64 " + %" PRId64 " is: %" PRId64,
      request_response_pair.first->a,
      request_response_pair.first->b,
      request_response_pair.second->sum);
  };
```

这里使用了 **按值捕获**（`logger = this->get_logger()`），
防止异步回调执行时 `this` 已经销毁导致悬空引用。

最后调用：

```cpp
auto result = client_->async_send_request(request, std::move(response_received_callback));
```

✅ **说明：**

* 该函数立即返回，不会阻塞；
* 响应到来时自动调用回调；
* executor 在子线程中会调度回调执行。

---

## ⚙️ 2️⃣ `main()` 主函数解析

### 🔹 2.1 初始化与创建节点

```cpp
rclcpp::init(argc, argv);
auto node = std::make_shared<ClientNode>();
```

---

### 🔹 2.2 等待服务上线

```cpp
if (!node->wait_for_service_server()) {
  return 1;
}
```

阻塞等待服务上线。

---

### 🔹 2.3 启动异步 executor 线程

```cpp
std::promise<void> stop_async_spinner;
std::thread async_spinner_thread(
  [stop_token = stop_async_spinner.get_future(), node]() {
    rclcpp::executors::SingleThreadedExecutor executor;
    executor.add_node(node);
    executor.spin_until_future_complete(stop_token);
  });
```

💡 重点：

* 创建了一个 **子线程** 来运行 ROS executor；
* 使用 `spin_until_future_complete(stop_token)` 可以在 `stop_async_spinner.set_value()` 时安全退出；
* 主线程仍然可以处理用户输入。

✅ **这就是 ROS 2 的“异步 spin 模式”**。

---

### 🔹 2.4 主线程读用户输入并发请求

```cpp
while (1) {
  auto optional_number = read_number(buffer, logger);
  ...
  node->queue_async_request(a, b);
}
```

* 用户输入两个数字；
* 调用 `queue_async_request()` 异步发出请求；
* 用户可以继续输入下一个请求，无需等待响应。

---

### 🔹 2.5 停止 executor

```cpp
stop_async_spinner.set_value();
async_spinner_thread.join();
rclcpp::shutdown();
```

主线程设置 promise 值，子线程检测到后退出 spin。

---

## ⚡ 3️⃣ Executor 与异步机制核心逻辑图

```
┌──────────────┐
│   MainThread │
│  - 读取输入   │
│  - 调用 queue │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   ClientNode │
│  - async_send_request() │
│  - 回调函数注册         │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ Executor线程 │
│  - spin_until_future_complete │
│  - 处理定时器和回调函数     │
└──────────────┘
```

---

## 🧠 4️⃣ 关键点总结

| 特性                        | 说明                                       |
| ------------------------- | ---------------------------------------- |
| 异步请求                      | 不阻塞主线程，可同时发出多个请求                         |
| 回调捕获                      | 用 `[logger = this->get_logger()]` 避免悬空引用 |
| executor 线程               | 独立线程处理回调、定时器等                            |
| promise + future          | 用于安全停止 executor                          |
| prune_requests_older_than | 清除超时请求，防止积压                              |

---

## 💬 一句话总结

> **主线程负责发请求，executor 子线程负责监听和回调。**
> 这种结构让 ROS 2 客户端可以“异步交互”，既不阻塞输入，也能及时处理响应。

---

非常好的问题 👍
你注意到的这行：

```cpp
timer_ = this->create_wall_timer(
  5s,
  [this]() {
    std::vector<int64_t> pruned_requests;
    size_t n_pruned = this->client_->prune_requests_older_than(
      std::chrono::system_clock::now() - 5s, &pruned_requests);
    if (n_pruned) {
      RCLCPP_INFO(
        this->get_logger(),
        "The server hasn't replied for more than 5s, %zu requests were discarded, "
        "the discarded requests numbers are:",
        n_pruned);
      for (const auto & req_num : pruned_requests) {
        RCLCPP_INFO(this->get_logger(), "\t%" PRId64, req_num);
      }
    }
  });
```

---

## 🧩 一句话解释

这个 **`timer_` 是一个“定时清理机制”**，
用来每隔 5 秒清理掉那些已经发出但服务端迟迟没有响应的旧请求。

---

## 🧱 详细解释

### 1️⃣ 创建定时器

```cpp
this->create_wall_timer(5s, callback);
```

`create_wall_timer()` 是 ROS 2 的定时器 API。

* 它基于 **“实时时钟（Wall Clock）”**（不是 ROS 时间）。
* 每隔指定时间间隔（这里是 5 秒）执行一次传入的回调函数。
* 这个定时器由 executor 线程管理，也就是说需要有 `spin()` 在运行，它才会周期性触发。

---

### 2️⃣ 回调函数的功能

```cpp
size_t n_pruned = this->client_->prune_requests_older_than(
  std::chrono::system_clock::now() - 5s, &pruned_requests);
```

这行调用了 ROS 2 的客户端 API：

```cpp
prune_requests_older_than(deadline, &out_ids);
```

它会：

* 遍历客户端中所有“还没收到响应的请求”；
* 找出那些“创建时间早于 `deadline`（即现在减去 5 秒）”的请求；
* 把它们移除（即“剪枝 prune”）；
* 可选地把这些被丢弃的请求 ID 填入 `pruned_requests` 输出参数。

---

### 3️⃣ 打印日志部分

```cpp
if (n_pruned) {
  RCLCPP_INFO(..., "%zu requests were discarded", n_pruned);
  for (const auto & req_num : pruned_requests)
    RCLCPP_INFO(..., "\t%" PRId64, req_num);
}
```

如果确实有超时的请求被清理掉，就会打印提示日志。

---

## 🧠 为什么要加这个定时器？

在 ROS 2 的异步客户端中，每次调用：

```cpp
auto result = client_->async_send_request(request, callback);
```

客户端会把请求保存在内部的一个“请求列表”里，等待响应到来时匹配 request_id 并调用回调。

但是：
如果服务器永远不响应（例如崩溃、断线、重启），这些请求就会一直留在客户端内存中。

长时间运行时，这可能造成：

* **内存泄漏**（请求对象永不释放）；
* **逻辑混乱**（因为客户端认为这些请求还“挂着”）；
* **无法区分旧请求和新请求**。

👉 所以官方示例加了一个定时器，每 5 秒检查一次并清理超时请求。

---

## ⚙️ 与 executor 的关系

这个 `timer_` 其实不会自己运行。

它的触发依赖于：

```cpp
executor.add_node(node);
executor.spin();
```

也就是说，`SingleThreadedExecutor` 在 spin 时会检测所有定时器、订阅、服务等事件。
定时器到期时，它会自动调用 `timer_` 对应的回调。

在这个程序中，executor 在子线程中运行：

```cpp
executor.spin_until_future_complete(stop_token);
```

所以定时器会在子线程中每 5 秒触发一次。

---

## 🧩 总结一下

| 项目       | 说明                                |
| -------- | --------------------------------- |
| **类型**   | `rclcpp::TimerBase::SharedPtr`    |
| **创建函数** | `create_wall_timer(5s, callback)` |
| **执行间隔** | 每隔 5 秒执行一次                        |
| **作用**   | 清理掉客户端中等待超过 5 秒、未收到响应的旧请求         |
| **依赖**   | executor 的 `spin()` 来触发           |
| **好处**   | 避免内存堆积、防止长时间未响应请求占用资源             |

---

是否希望我画一个小图（显示“异步请求 → 超时 → 定时器清理”的流程）？
这个图能帮你更直观看懂 `timer_` 在 ROS 异步机制中的作用。
