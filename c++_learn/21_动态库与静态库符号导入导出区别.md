非常棒 👍，你抓到重点了！
是的，**和 `.a`（静态库）或 `.out`（可执行文件）完全不同**。
我们来系统地比较一下它们的编译与链接机制，这样你就会彻底明白为什么 `CUSTOM_ACTION_CPP_BUILDING_DLL` 这类宏 **只在动态库** 中需要 👇

---

## 🧩 一、三种产物的区别概览

| 类型        | 文件后缀           | 链接方式            | 是否需要导出控制   | 特点                   |
| --------- | -------------- | --------------- | ---------- | -------------------- |
| **静态库**   | `.a` / `.lib`  | 编译时直接打包进最终可执行文件 | ❌ 不需要      | 最终生成的 `.out` 含所有代码拷贝 |
| **动态库**   | `.so` / `.dll` | 运行时动态加载         | ✅ 需要控制导出符号 | 节省内存，可被多个程序共用        |
| **可执行文件** | `.out` / 无后缀   | 独立运行            | ❌ 不需要      | 包含 main() 和所有依赖代码    |

---

## 🧱 二、静态库 `.a` 是怎么工作的

当你执行：

```bash
ar rcs libmylib.a file1.o file2.o
```

这只是把一堆 `.o` 文件 **打包** 成一个档案。

然后在可执行程序编译时：

```bash
g++ main.cpp -L. -lmylib -o app.out
```

链接器会把 **用到的函数对象代码** 拷贝进 app.out 里。

> 所以 `.a` 文件不会在运行时被加载，也不需要“导出函数”。

💡 不需要 `__declspec(dllexport)` 之类的宏。
你写的所有函数都能直接用。

---

## 🧱 三、动态库 `.so` / `.dll` 工作机制

当你执行：

```bash
g++ -shared -o libmylib.so file1.o file2.o
```

你生成了一个 **运行时加载的模块**。
程序运行时通过动态链接器（`ld-linux.so`）加载。

此时就有两个阶段：

1. 编译时：你只告诉编译器这些函数来自外部库（通过 `.so` 和头文件）
2. 运行时：动态链接器在内存中找到这些符号地址，再绑定过去

💡 所以编译器必须清楚：哪些符号要导出、哪些隐藏。

这就是：

```cpp
CUSTOM_ACTION_CPP_PUBLIC
```

的存在意义。

---

## 🪄 四、为什么动态库需要「导出」和「导入」

因为 `.so` / `.dll` 文件内部可能包含很多函数、类、静态变量等，
但只有部分是要给外部程序用的。

> **导出（export）**：告诉编译器“这个符号要放到导出表里”。
>
> **导入（import）**：告诉编译器“这个符号来自别的库，不要在这里定义”。

在 Windows 下，这个导出表是 `.dll` 的重要结构；
在 Linux 下，对应 ELF 文件里的 **Dynamic Symbol Table (`.dynsym`)**。

---

## 🧩 五、回到你的例子：

```cmake
add_library(custom_action_cpp SHARED src/custom_action.cpp)
target_compile_definitions(custom_action_cpp PRIVATE "CUSTOM_ACTION_CPP_BUILDING_DLL")
```

👉 意思是告诉编译器：

> “这次我在编译 `.so`，要导出我的 API。”

然后在别的包中：

```cmake
find_package(custom_action_cpp REQUIRED)
target_link_libraries(other_node custom_action_cpp)
```

因为没有定义 `CUSTOM_ACTION_CPP_BUILDING_DLL`，
宏展开为 `CUSTOM_ACTION_CPP_IMPORT`，
告诉编译器这些符号来自外部库。

---

## 🧩 六、总结对比图

| 场景         | 是否动态加载 | 是否需要控制导出 | 是否会复制代码   |
| ---------- | ------ | -------- | --------- |
| `.a` 静态库   | ❌ 否    | ❌ 不需要    | ✅ 是       |
| `.so` 动态库  | ✅ 是    | ✅ 需要     | ❌ 否       |
| `.out` 可执行 | ❌ 否    | ❌ 不需要    | ✅ 已包含全部代码 |

---

✅ **一句话总结：**

> 静态库是“打包拷贝”，动态库是“运行时引用”。
> 因此，只有动态库需要导入导出宏控制哪些符号能被别人用。

---

要不要我帮你写一段小实验代码（一个 `.a` 和一个 `.so`）对比一下导出符号的差异？
可以直接在你的 Ubuntu 上编译、`nm` 查看结果，非常直观。
