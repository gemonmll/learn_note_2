å¥½ï¼Œè¿™æ®µä»£ç **éå¸¸å…³é”®**ï¼Œå®ƒæŠŠä½ å‰é¢çœ‹åˆ°çš„ **CRTP + äº‹ä»¶ç³»ç»Ÿ** ä¸²æˆäº†ä¸€ä¸ª**å®Œæ•´çš„â€œæ‰‹å†™å›è°ƒ/ç»‘å®šæ¡†æ¶â€**ã€‚
æˆ‘æŒ‰**ä»æ•´ä½“ â†’ ç»†èŠ‚ â†’ è°ƒç”¨æµç¨‹ â†’ å’Œ CRTP çš„å…³ç³»**ä¸€æ­¥ä¸€æ­¥ç»™ä½ æ‹†ã€‚

---

# ä¸€ã€ä¸€å¥è¯æ€»è§ˆï¼ˆå…ˆç»™ç»“è®ºï¼‰

è¿™å¥—ä»£ç å®ç°çš„æ˜¯ï¼š

> **ä¸€ä¸ªâ€œå¯¹è±¡ + æˆå‘˜å‡½æ•°â€çš„äº‹ä»¶ç»‘å®šç³»ç»Ÿï¼ˆç±»ä¼¼ std::bind / std::functionï¼‰ï¼Œ
> ç”¨è™šå‡½æ•°åšâ€œç»Ÿä¸€å›è°ƒå…¥å£â€ï¼Œ
> ç”¨æ¨¡æ¿ä¿å­˜â€œå…·ä½“å¯¹è±¡ + æˆå‘˜å‡½æ•°æŒ‡é’ˆâ€ï¼Œ
> å†é€šè¿‡ CTrigger æŒ‰ event åˆ†å‘è°ƒç”¨ã€‚**

åŒæ—¶ï¼š

* `CHandler<T>` ç”¨ **CRTP** ç»™ä¸šåŠ¡ç±»â€œé…å¥—å­˜å‚¨å›è°ƒå¯¹è±¡çš„å®¹å™¨â€
* `FunObj / FunObjT<T>` ç”¨ **è¿è¡Œæ—¶å¤šæ€ï¼ˆvirtualï¼‰** åšâ€œç»Ÿä¸€è°ƒç”¨æ¥å£â€

ğŸ‘‰ **è¿™æ˜¯ä¸€ä¸ªâ€œCRTP + è¿è¡Œæ—¶å¤šæ€æ··åˆè®¾è®¡â€**

---

# äºŒã€æ•´ä½“ç»“æ„å›¾ï¼ˆéå¸¸é‡è¦ï¼‰

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CTrigger  â”‚  â† äº‹ä»¶ä¸­å¿ƒ
â”‚            â”‚
â”‚  EventCBS  â”‚â”€â”€ event â†’ FunObj*
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚ call_fun()
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FunObj    â”‚  â† æŠ½è±¡å›è°ƒåŸºç±»ï¼ˆvirtualï¼‰
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FunObjT<T> â”‚  â† æ¨¡æ¿ï¼šä¿å­˜ T* + æˆå‘˜å‡½æ•°æŒ‡é’ˆ
â”‚  obj_ptr   â”‚
â”‚  fun_ptr   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CHandler<T>â”‚  â† CRTPï¼šç»™ T æä¾› FunObj å­˜å‚¨æ± 
â”‚ m_funobjs  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸šåŠ¡ç±» T  â”‚  â† FusionResHandler ä¹‹ç±»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ä¸‰ã€æ ¸å¿ƒç±»é€ä¸ªæ‹†è§£

## 1ï¸âƒ£ FunObj â€”â€” **ç»Ÿä¸€å›è°ƒæ¥å£ï¼ˆè¿è¡Œæ—¶å¤šæ€ï¼‰**

```cpp
class FunObj
{
public:
    virtual void call_fun(int32_t event, void *obj, uint64_t tick) {}
};
```

### ä½œç”¨

* æ‰€æœ‰å›è°ƒ **ç»Ÿä¸€ç”¨ FunObj*** ä¿å­˜
* `CTrigger` **ä¸å…³å¿ƒå…·ä½“ç±»å‹**
* åªè¦èƒ½ `call_fun()` å°±è¡Œ

ğŸ“Œ è¿™ä¸€æ­¥ **å¿…é¡»ç”¨ virtual**ï¼Œå› ä¸ºï¼š

> CTrigger åªæ‹¿åˆ° `FunObj*`ï¼Œä¸çŸ¥é“çœŸå®ç±»å‹

---

## 2ï¸âƒ£ FunObjT<T> â€”â€” **å¯¹è±¡ + æˆå‘˜å‡½æ•°çš„â€œèƒ¶æ°´â€**

```cpp
template <class T>
class FunObjT : public FunObj
{
public:
    typedef void (T::*pMemFunc)(int32_t, void *, uint64_t);

    T *obj_ptr;
    pMemFunc fun_ptr;

    virtual void call_fun(int32_t event, void *obj, uint64_t tick)
    {
        (obj_ptr->*fun_ptr)(event, obj, tick);
    }
};
```

### è¿™å°±æ˜¯â€œæ‰‹å†™ç‰ˆ std::bindâ€

å®ƒä¿å­˜äº†ï¼š

* âœ… **å¯¹è±¡æŒ‡é’ˆ** `T*`
* âœ… **æˆå‘˜å‡½æ•°æŒ‡é’ˆ** `void (T::*)(...)`

è°ƒç”¨æ—¶ï¼š

```cpp
(obj_ptr->*fun_ptr)(...)
```

ğŸ“Œ **è¿™ä¸€æ­¥æ‰çœŸæ­£è°ƒç”¨ä½ çš„ä¸šåŠ¡å‡½æ•°**

---

## 3ï¸âƒ£ simplebind â€”â€” **ç»‘å®šåŠ¨ä½œå‘ç”Ÿçš„åœ°æ–¹ï¼ˆé‡ç‚¹ï¼‰**

```cpp
template <class T>
FunObj *simplebind(typename FunObjT<T>::pMemFunc func_ptr, T *ptr)
{
    typename T::FunObjVector::iterator it =
        ptr->m_funobjs.emplace_back_itor();

    it->fun_ptr = func_ptr;
    it->obj_ptr = ptr;

    return it.operator->();
}
```

### è¿™é‡Œå‘ç”Ÿäº†ä¸‰ä»¶éå¸¸é‡è¦çš„äº‹

#### âœ… â‘  FunObjT å­˜åœ¨ **ä¸šåŠ¡å¯¹è±¡å†…éƒ¨**

```cpp
ptr->m_funobjs
```

è¿™æ¥è‡ªï¼š

```cpp
CHandler<T>
```

ğŸ‘‰ **CRTP çš„ä½œç”¨ç‚¹åœ¨è¿™é‡Œ**

---

#### âœ… â‘¡ æ²¡æœ‰ new / delete

* å›è°ƒå¯¹è±¡å­˜åœ¨ `circleVector` é‡Œ
* **æ²¡æœ‰å †åˆ†é…**
* éå¸¸é€‚åˆ ECU / å®æ—¶ç³»ç»Ÿ

---

#### âœ… â‘¢ è¿”å› FunObj*

```cpp
return it.operator->();
```

* å¯¹å¤–â€œæ“¦é™¤ç±»å‹â€
* å†…éƒ¨ä»ç„¶æ˜¯ `FunObjT<T>`

---

## 4ï¸âƒ£ CHandler<T> â€”â€” **CRTP çš„çœŸæ­£ç”¨é€”**

```cpp
template <class T>
class CHandler : public CObject {
public:
    typedef circleVector<FunObjT<T>, MAX_HANDLER_NUM> FunObjVector;
    FunObjVector m_funobjs;
};
```

### è¿™å°±æ˜¯ CRTP çš„â€œå®¹å™¨æ³¨å…¥â€

ä¸šåŠ¡ç±»ï¼š

```cpp
class FusionResHandler
    : public CHandler<FusionResHandler>
{
};
```

ç­‰ä»·äºï¼š

> â€œ**ç»™ FusionResHandler è‡ªåŠ¨åŠ ä¸€ä¸ª
> `circleVector<FunObjT<FusionResHandler>>`**â€

ğŸ“Œ **æ¯ä¸ª Handler ç±»å‹æœ‰è‡ªå·±ç‹¬ç«‹çš„ FunObjT ç±»å‹æ± **

---

## 5ï¸âƒ£ CTrigger â€”â€” **äº‹ä»¶ä¸­å¿ƒ**

```cpp
class CTrigger {
public:
    struct EventHandler {
        int32_t event;
        FunObj *cb;
    };

    EventCBS m_event_cbs;

    void TriggerEvent(int32_t event, void *obj, uint64_t tick)
    {
        for (...) {
            if (m_event_cbs[i].event == event) {
                m_event_cbs[i].cb->call_fun(event, obj, tick);
            }
        }
    }
};
```

### å…³é”®ç‚¹

* åªè®¤ `FunObj*`
* ä¸çŸ¥é“ T
* ä¸çŸ¥é“æˆå‘˜å‡½æ•°
* åªç®¡è§¦å‘

ğŸ‘‰ **å…¸å‹çš„â€œå‘å¸ƒ-è®¢é˜… / äº‹ä»¶æ€»çº¿â€**

---

# å››ã€å®Œæ•´è°ƒç”¨æµç¨‹ï¼ˆä¸€æ­¥ä¸è·³ï¼‰

ä»¥ä½ çœŸå®ä¸šåŠ¡ä¸ºä¾‹ï¼š

```cpp
class FusionResHandler
    : public CHandler<FusionResHandler>
{
public:
    void OnRecvRes(int32_t e, void* o, uint64_t t);
};
```

---

### â‘  ç»‘å®šé˜¶æ®µï¼ˆåˆå§‹åŒ–ï¼‰

```cpp
auto fo = simplebind(
    &FusionResHandler::OnRecvRes,
    &fusion_handler
);

trigger.AddEventHandler(fo, EVENT_FUSION_DDSFLOW);
```

---

### â‘¡ è§¦å‘é˜¶æ®µï¼ˆè¿è¡ŒæœŸï¼‰

```cpp
trigger.TriggerEvent(EVENT_FUSION_DDSFLOW, obj, tick);
```

å±•å¼€ä¸ºï¼š

```cpp
FunObj* cb = ...
cb->call_fun(...)
```

---

### â‘¢ è™šå‡½æ•°åˆ†å‘

```cpp
FunObjT<FusionResHandler>::call_fun(...)
```

---

### â‘£ æˆå‘˜å‡½æ•°çœŸæ­£æ‰§è¡Œ

```cpp
(fusion_handler.*OnRecvRes)(...)
```

ğŸ¯ **å‘½ä¸­ä½ çš„ä¸šåŠ¡ä»£ç **

---

# äº”ã€ä¸ºä»€ä¹ˆè¿™é‡Œä¸ç”¨çº¯ CRTPï¼Ÿ

ä½ å¯èƒ½ä¼šé—®ä¸€ä¸ª**éå¸¸é«˜çº§çš„é—®é¢˜**ï¼š

> â“ è¿™é‡Œä¸ºä»€ä¹ˆä¸ç”¨â€œçº¯ CRTP + static_castâ€ï¼Œè€Œè¦ virtualï¼Ÿ

### ç­”æ¡ˆæ˜¯ï¼š**å› ä¸ºäº‹ä»¶è¡¨æ˜¯â€œå¼‚æ„çš„â€**

```cpp
EventHandler {
    int32_t event;
    FunObj* cb;   // â† ä¸åŒ T
}
```

* ä¸€ä¸ª Trigger é‡Œï¼š

  * å¯èƒ½æ˜¯ FusionResHandler
  * å¯èƒ½æ˜¯ HmiHandler
  * å¯èƒ½æ˜¯ PlanningHandler

ğŸ‘‰ **è¿è¡ŒæœŸæ‰çŸ¥é“æ˜¯è°**

ğŸ“Œ æ‰€ä»¥ï¼š

* **å­˜å‚¨å±‚ï¼šå¿…é¡» runtime polymorphism**
* **ç»‘å®šå±‚ï¼šç”¨æ¨¡æ¿ç”Ÿæˆå¼ºç±»å‹**
* **å­˜å‚¨å±‚å’Œä¸šåŠ¡å±‚ä¹‹é—´ï¼šç±»å‹æ“¦é™¤**

---

# å…­ã€è¿™å¥—è®¾è®¡çš„å·¥ç¨‹ä»·å€¼ï¼ˆä½ è¿™è¡Œä»£ç ä¸ºä»€ä¹ˆé«˜çº§ï¼‰

| ç‚¹            | ä»·å€¼             |
| ------------ | -------------- |
| æ—  new/delete | ECU å‹å¥½         |
| æˆå‘˜å‡½æ•°ç»‘å®š       | ç±»å‹å®‰å…¨           |
| CRTP         | æ¯ä¸ª Handler ç‹¬ç«‹æ±  |
| FunObj è™šæ¥å£   | äº‹ä»¶ç³»ç»Ÿè§£è€¦         |
| circleVector | å›ºå®šå®¹é‡ã€å®æ—¶å®‰å…¨      |

ğŸ‘‰ **è¿™æ˜¯â€œè½¦è§„çº§ C++â€çš„å…¸å‹å†™æ³•**

---

# ä¸ƒã€æŠŠå®ƒå’Œä½ æœ€å¼€å§‹çš„ CRTP Handler å¯¹ä¸Š

ä½ æœ€æ—©çš„ä»£ç ï¼š

```cpp
class FusionResHandler
  : public FRAMEWORK::CHandler<FusionResHandler>
{
    void OnRecvRes(...) {
        TriggerEvent(...)
    }
};
```

ç°åœ¨ä½ åº”è¯¥èƒ½çœ‹æ‡‚äº†ï¼š

* `CHandler<FusionResHandler>`
  ğŸ‘‰ **ç»™ä½ å›è°ƒå¯¹è±¡æ± **
* `simplebind`
  ğŸ‘‰ **æŠŠ OnRecvRes å˜æˆ FunObj**
* `CTrigger`
  ğŸ‘‰ **æŒ‰ event è°ƒç”¨**

---

# å…«ã€ä¸€å¥è¯ç»ˆææ€»ç»“ï¼ˆå»ºè®®ä½ è®°ä½ï¼‰

> **CRTP ç”¨æ¥â€œæŠŠèƒ½åŠ›å’Œå­˜å‚¨æ³¨å…¥åˆ°ä¸šåŠ¡ç±»â€ï¼Œ
> virtual ç”¨æ¥â€œåœ¨è¿è¡ŒæœŸåšç»Ÿä¸€è°ƒåº¦â€ï¼Œ
> æ¨¡æ¿ + è™šå‡½æ•°ç»„åˆï¼Œæ‰æ˜¯å·¥ç¨‹é‡Œæœ€å¸¸è§ã€æœ€ç¨³å¦¥çš„æ–¹æ¡ˆã€‚**

---

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥å¸®ä½ åšä¸‰ä»¶äº‹ä¹‹ä¸€ï¼š

1ï¸âƒ£ æŠŠè¿™å¥—ä»£ç  **æ”¹æˆ std::function ç‰ˆæœ¬** å¯¹æ¯”ä¼˜ç¼ºç‚¹
2ï¸âƒ£ ç”»ä¸€å¼  **â€œTrigger â†’ FunObj â†’ Handlerâ€ è°ƒç”¨æ—¶åºå›¾**
3ï¸âƒ£ å¸®ä½  **é‡æ„æˆç°ä»£ C++17/20 å†™æ³•ï¼ˆä½†ä»è½¦è§„å‹å¥½ï¼‰**

ä½ é€‰ä¸€ä¸ªï¼Œæˆ‘æŒ‰ä½ é¡¹ç›®èƒŒæ™¯ç»§ç»­å¾€ä¸‹æ‹†ã€‚
```cpp
//
//created by xuhuandong
//
#ifndef _simpleBind_10_56_29_H
#define _simpleBind_10_56_29_H
#include <stdint.h>
#include "circleVector.h"
#include "CObject.h"
namespace FRAMEWORK
{
    class FunObj
    {
    public:
        virtual void call_fun(int32_t event, void *obj, uint64_t tick){
            
        };
    };
    template <class T>
    class FunObjT : public FunObj
    {
    public:
        typedef void (T::*pMemFunc)(int32_t, void *, uint64_t);
        T *obj_ptr;
        pMemFunc fun_ptr;
        FunObjT(T *ptr, pMemFunc func)
        {
            obj_ptr = ptr;
            fun_ptr = func;
        }
        FunObjT()
        {
            obj_ptr = NULL;
            fun_ptr = NULL;
        }
        virtual void call_fun(int32_t event, void *obj, uint64_t tick)
        {
            (obj_ptr->*fun_ptr)(event, obj, tick);
        }
    };
    template <class T>
    FunObj *simplebind(typename FunObjT<T>::pMemFunc func_ptr, T *ptr)
    {
        typename T::FunObjVector::iterator it = ptr->m_funobjs.emplace_back_itor();
        it->fun_ptr = func_ptr;
        it->obj_ptr = ptr;
        return it.operator->();
    }

    class CTrigger:public CObject{
        public:
            class EventHandler
            {
            public:
                int32_t event;
                FunObj *cb;
            };
            #ifndef MAX_EVENT_NUM
            #define MAX_EVENT_NUM 6
            #endif
            typedef circleVector<EventHandler, MAX_EVENT_NUM> EventCBS;
            EventCBS m_event_cbs;
            void AddEventHandler(FunObj *fo, int32_t event)
            {
                EventHandler eh;
                eh.cb = fo;
                eh.event = event;
                m_event_cbs.push_back(eh);
            }
            void TriggerEvent(int32_t event, void *obj, uint64_t tick)
            {
                for (int i = 0; i < m_event_cbs.size(); i++)
                {
                    if (m_event_cbs[i].event == event)
                    {
                        m_event_cbs[i].cb->call_fun(event, obj, tick);
                    }
                }
            }    
    };
    template <class T>
    class CHandler:public CObject{
        public:
#ifndef MAX_HANDLER_NUM
#define MAX_HANDLER_NUM 6
#endif

            typedef circleVector<FunObjT<T>, MAX_HANDLER_NUM> FunObjVector;
            FunObjVector m_funobjs;
    };
}

#endif
```