```cpp
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2023. All rights reserved.
 */

#ifndef DATATYPES_IMPL_TYPE_IDT_BRK_NOTIFYCYCLEYAWRATESENSOR6_EGO_STRT_H
#define DATATYPES_IMPL_TYPE_IDT_BRK_NOTIFYCYCLEYAWRATESENSOR6_EGO_STRT_H

#include <cfloat>
#include <cmath>
#include "datatypes/impl_type_idt_imu_notifycycleimudatasensorstatus_ref.h"
#include "datatypes/impl_type_idt_imu_accelerationx_float_meterpersencondsquare_ref.h"
#include "datatypes/impl_type_idt_imu_angularvelocityx_float_radpersecond_ref.h"
#include "datatypes/impl_type_idt_imu_stausflagx_enum_ref.h"
#include "datatypes/impl_type_idt_imu_accelerationy_float_meterpersencondsquare_ref.h"
#include "datatypes/impl_type_idt_imu_angularvelocityy_float_radpersecond_ref.h"
#include "datatypes/impl_type_idt_imu_stausflagy_enum_ref.h"
#include "datatypes/impl_type_idt_imu_accelerationz_float_meterpersencondsquare_ref.h"
#include "datatypes/impl_type_idt_imu_angularvelocityz_float_radpersecond_ref.h"
#include "datatypes/impl_type_idt_imu_stausflagz_enum_ref.h"
#include "datatypes/impl_type_idt_imu_airqlysnsrresperr_enum_ref.h"
#include "datatypes/impl_type_idt_imu_snsrtoggleerr_enum_ref.h"
#include "datatypes/impl_type_idt_imu_snsrcomerr_enum_ref.h"
#include "datatypes/impl_type_idt_timestamp_ref.h"

namespace datatypes {
struct IDT_Brk_NotifyCycleYawRateSensor6_ego_strt {
    ::datatypes::IDT_IMU_NotifyCycleIMUDataSensorStatus_ref Chas_IMU_NotifyCycleIMUDataSensorStatus{ ::datatypes::IDT_IMU_NotifyCycleIMUDataSensorStatus_ref::IMUDataSensorStatus_init };
    ::datatypes::IDT_IMU_AccelerationX_float_meterpersencondsquare_ref Chas_IMU_AccelerationX{ 0.0F };
    ::datatypes::IDT_IMU_AngularVelocityX_float_Radpersecond_ref Chas_IMU_AngularVelocityX{ 0.0F };
    ::datatypes::IDT_IMU_StausFlagX_enum_ref Chas_IMU_StausFlagX{ ::datatypes::IDT_IMU_StausFlagX_enum_ref::StausFlagX_init };
    ::datatypes::IDT_IMU_AccelerationY_float_meterpersencondsquare_ref Chas_IMU_AccelerationY{ 0.0F };
    ::datatypes::IDT_IMU_AngularVelocityY_float_Radpersecond_ref Chas_IMU_AngularVelocityY{ 0.0F };
    ::datatypes::IDT_IMU_StausFlagY_enum_ref Chas_IMU_StausFlagY{ ::datatypes::IDT_IMU_StausFlagY_enum_ref::StausFlagY_init };
    ::datatypes::IDT_IMU_AccelerationZ_float_meterpersencondsquare_ref Chas_IMU_AccelerationZ{ 0.0F };
    ::datatypes::IDT_IMU_AngularVelocityZ_float_Radpersecond_ref Chas_IMU_AngularVelocityZ{ 0.0F };
    ::datatypes::IDT_IMU_StausFlagZ_enum_ref Chas_IMU_StausFlagZ{ ::datatypes::IDT_IMU_StausFlagZ_enum_ref::StausFlagZ_init };
    ::datatypes::IDT_IMU_AirQlySnsrRespErr_enum_ref Chas_IMU_AirQlySnsrRespErr{ ::datatypes::IDT_IMU_AirQlySnsrRespErr_enum_ref::AirQlySnsrRespErr_error };
    ::datatypes::IDT_IMU_SnsrToggleErr_enum_ref Chas_IMU_SnsrToggleErr{ ::datatypes::IDT_IMU_SnsrToggleErr_enum_ref::SnsrToggleErr_error };
    ::datatypes::IDT_IMU_SnsrComErr_enum_ref Chas_IMU_SnsrComErr{ ::datatypes::IDT_IMU_SnsrComErr_enum_ref::SnsrComErr_error };
    ::datatypes::IDT_Timestamp_ref Timestamp{ 0U };

    static bool IsPlane()
    {
        return true;
    }


    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(Chas_IMU_NotifyCycleIMUDataSensorStatus);
        fun(Chas_IMU_AccelerationX);
        fun(Chas_IMU_AngularVelocityX);
        fun(Chas_IMU_StausFlagX);
        fun(Chas_IMU_AccelerationY);
        fun(Chas_IMU_AngularVelocityY);
        fun(Chas_IMU_StausFlagY);
        fun(Chas_IMU_AccelerationZ);
        fun(Chas_IMU_AngularVelocityZ);
        fun(Chas_IMU_StausFlagZ);
        fun(Chas_IMU_AirQlySnsrRespErr);
        fun(Chas_IMU_SnsrToggleErr);
        fun(Chas_IMU_SnsrComErr);
        fun(Timestamp);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(Chas_IMU_NotifyCycleIMUDataSensorStatus);
        fun(Chas_IMU_AccelerationX);
        fun(Chas_IMU_AngularVelocityX);
        fun(Chas_IMU_StausFlagX);
        fun(Chas_IMU_AccelerationY);
        fun(Chas_IMU_AngularVelocityY);
        fun(Chas_IMU_StausFlagY);
        fun(Chas_IMU_AccelerationZ);
        fun(Chas_IMU_AngularVelocityZ);
        fun(Chas_IMU_StausFlagZ);
        fun(Chas_IMU_AirQlySnsrRespErr);
        fun(Chas_IMU_SnsrToggleErr);
        fun(Chas_IMU_SnsrComErr);
        fun(Timestamp);
    }

    template<typename F>
    void enumerate_internal(F& fun)
    {
        fun("Chas_IMU_NotifyCycleIMUDataSensorStatus", Chas_IMU_NotifyCycleIMUDataSensorStatus);
        fun("Chas_IMU_AccelerationX", Chas_IMU_AccelerationX);
        fun("Chas_IMU_AngularVelocityX", Chas_IMU_AngularVelocityX);
        fun("Chas_IMU_StausFlagX", Chas_IMU_StausFlagX);
        fun("Chas_IMU_AccelerationY", Chas_IMU_AccelerationY);
        fun("Chas_IMU_AngularVelocityY", Chas_IMU_AngularVelocityY);
        fun("Chas_IMU_StausFlagY", Chas_IMU_StausFlagY);
        fun("Chas_IMU_AccelerationZ", Chas_IMU_AccelerationZ);
        fun("Chas_IMU_AngularVelocityZ", Chas_IMU_AngularVelocityZ);
        fun("Chas_IMU_StausFlagZ", Chas_IMU_StausFlagZ);
        fun("Chas_IMU_AirQlySnsrRespErr", Chas_IMU_AirQlySnsrRespErr);
        fun("Chas_IMU_SnsrToggleErr", Chas_IMU_SnsrToggleErr);
        fun("Chas_IMU_SnsrComErr", Chas_IMU_SnsrComErr);
        fun("Timestamp", Timestamp);
    }

    template<typename F>
    void enumerate_internal(F& fun) const
    {
        fun("Chas_IMU_NotifyCycleIMUDataSensorStatus", Chas_IMU_NotifyCycleIMUDataSensorStatus);
        fun("Chas_IMU_AccelerationX", Chas_IMU_AccelerationX);
        fun("Chas_IMU_AngularVelocityX", Chas_IMU_AngularVelocityX);
        fun("Chas_IMU_StausFlagX", Chas_IMU_StausFlagX);
        fun("Chas_IMU_AccelerationY", Chas_IMU_AccelerationY);
        fun("Chas_IMU_AngularVelocityY", Chas_IMU_AngularVelocityY);
        fun("Chas_IMU_StausFlagY", Chas_IMU_StausFlagY);
        fun("Chas_IMU_AccelerationZ", Chas_IMU_AccelerationZ);
        fun("Chas_IMU_AngularVelocityZ", Chas_IMU_AngularVelocityZ);
        fun("Chas_IMU_StausFlagZ", Chas_IMU_StausFlagZ);
        fun("Chas_IMU_AirQlySnsrRespErr", Chas_IMU_AirQlySnsrRespErr);
        fun("Chas_IMU_SnsrToggleErr", Chas_IMU_SnsrToggleErr);
        fun("Chas_IMU_SnsrComErr", Chas_IMU_SnsrComErr);
        fun("Timestamp", Timestamp);
    }

    friend bool operator==(const ::datatypes::IDT_Brk_NotifyCycleYawRateSensor6_ego_strt& lhs, const ::datatypes::IDT_Brk_NotifyCycleYawRateSensor6_ego_strt& rhs) noexcept
    {
        return (lhs.Chas_IMU_NotifyCycleIMUDataSensorStatus == rhs.Chas_IMU_NotifyCycleIMUDataSensorStatus) && (fabs(static_cast<double>(lhs.Chas_IMU_AccelerationX - rhs.Chas_IMU_AccelerationX)) < DBL_EPSILON) && (fabs(static_cast<double>(lhs.Chas_IMU_AngularVelocityX - rhs.Chas_IMU_AngularVelocityX)) < DBL_EPSILON) && (lhs.Chas_IMU_StausFlagX == rhs.Chas_IMU_StausFlagX) && (fabs(static_cast<double>(lhs.Chas_IMU_AccelerationY - rhs.Chas_IMU_AccelerationY)) < DBL_EPSILON) && (fabs(static_cast<double>(lhs.Chas_IMU_AngularVelocityY - rhs.Chas_IMU_AngularVelocityY)) < DBL_EPSILON) && (lhs.Chas_IMU_StausFlagY == rhs.Chas_IMU_StausFlagY) && (fabs(static_cast<double>(lhs.Chas_IMU_AccelerationZ - rhs.Chas_IMU_AccelerationZ)) < DBL_EPSILON) && (fabs(static_cast<double>(lhs.Chas_IMU_AngularVelocityZ - rhs.Chas_IMU_AngularVelocityZ)) < DBL_EPSILON) && (lhs.Chas_IMU_StausFlagZ == rhs.Chas_IMU_StausFlagZ) && (lhs.Chas_IMU_AirQlySnsrRespErr == rhs.Chas_IMU_AirQlySnsrRespErr) && (lhs.Chas_IMU_SnsrToggleErr == rhs.Chas_IMU_SnsrToggleErr) && (lhs.Chas_IMU_SnsrComErr == rhs.Chas_IMU_SnsrComErr) && (lhs.Timestamp == rhs.Timestamp);
    }
};
} // namespace datatypes


#endif // DATATYPES_IMPL_TYPE_IDT_BRK_NOTIFYCYCLEYAWRATESENSOR6_EGO_STRT_H


```
