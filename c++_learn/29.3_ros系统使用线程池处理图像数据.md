## ç¬¬1éƒ¨åˆ† é¡¹ç›®åº”ç”¨

éå¸¸å¥½ ğŸ‘ æˆ‘ä»¬å°±è¿›å…¥æœ€å®ç”¨çš„ä¸€èŠ‚â€”â€”**åœ¨ ROSï¼ˆRobot Operating Systemï¼‰ä¸­åº”ç”¨çº¿ç¨‹æ± **ã€‚
ä½ å­¦å®Œè¿™ä¸€èŠ‚åï¼Œå°±èƒ½åœ¨å®é™…é¡¹ç›®ï¼ˆå¦‚è‡ªåŠ¨é©¾é©¶ã€æ„ŸçŸ¥ã€SLAMç­‰ï¼‰ä¸­ç”¨çº¿ç¨‹æ± **å¹¶è¡Œå¤„ç†è®¡ç®—ä»»åŠ¡ã€å¼‚æ­¥å›è°ƒã€åŠ é€ŸèŠ‚ç‚¹å“åº”**ã€‚

---

## ğŸ§© ä¸€ã€ä¸ºä»€ä¹ˆ ROS é‡Œéœ€è¦çº¿ç¨‹æ± ï¼Ÿ

ROS è‡ªå¸¦çš„å›è°ƒæœºåˆ¶ï¼ˆ`ros::spin()` / `ros::spinOnce()`ï¼‰è™½ç„¶æ–¹ä¾¿ï¼Œä½†ï¼š

| é—®é¢˜     | åŸå›           |
| ------ | ----------- |
| å›è°ƒå¤„ç†æ…¢  | å•çº¿ç¨‹å¤„ç†æ‰€æœ‰è®¢é˜…æ¶ˆæ¯ |
| é«˜é¢‘æ¶ˆæ¯å †ç§¯ | æ¶ˆæ¯å¤„ç†è€—æ—¶ï¼Œé˜Ÿåˆ—å µå¡ |
| èŠ‚ç‚¹å“åº”å¡é¡¿ | å›è°ƒé˜»å¡åæ•´ä¸ªèŠ‚ç‚¹åœé¡¿ |

ğŸ‘‰ çº¿ç¨‹æ± èƒ½è®©å¤šä¸ªæ¶ˆæ¯**å¹¶è¡Œå¤„ç†**ï¼ŒåŒæ—¶ä¿æŒèŠ‚ç‚¹å®æ—¶å“åº”ã€‚

---

## âš™ï¸ äºŒã€å…¸å‹åº”ç”¨åœºæ™¯

| åœºæ™¯          | è¯´æ˜            |
| ----------- | ------------- |
| L2 / AEB æ§åˆ¶ | å¹¶è¡Œè®¡ç®—ä¸åŒä¼ æ„Ÿå™¨èåˆç»“æœ |
| æ„ŸçŸ¥æ¨¡å—        | å¹¶è¡Œå¤„ç†å¤šè·¯ç›¸æœºæˆ–é›·è¾¾å¸§  |
| è½¨è¿¹è§„åˆ’        | åŒæ—¶é¢„æµ‹å¤šæ¡å€™é€‰è½¨è¿¹    |
| SLAM        | åç«¯ä¼˜åŒ–ä¸å‰ç«¯è·Ÿè¸ªå¼‚æ­¥æ‰§è¡Œ |

---

## ğŸ§± ä¸‰ã€ç¤ºä¾‹ï¼šåœ¨ ROS èŠ‚ç‚¹ä¸­ä½¿ç”¨çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªèŠ‚ç‚¹è®¢é˜…å›¾åƒè¯é¢˜ `/camera/image`ï¼Œæ¯å¸§å›¾åƒéƒ½è¦è¿›è¡Œè¾ƒé‡çš„å¤„ç†ï¼ˆä¾‹å¦‚æ£€æµ‹æˆ–ç‰¹å¾æå–ï¼‰ï¼Œ
å¦‚æœç›´æ¥åœ¨å›è°ƒé‡Œæ‰§è¡Œï¼Œä¼šé˜»å¡ä¸‹ä¸€å¸§ã€‚

ğŸ‘‰ æˆ‘ä»¬ç”¨çº¿ç¨‹æ± æ¥â€œå¼‚æ­¥â€æ‰§è¡Œå›¾åƒå¤„ç†ã€‚

---

### ğŸ”§ ç¤ºä¾‹ä»£ç ï¼ˆROS1ï¼‰

```cpp
#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <opencv2/opencv.hpp>
#include <cv_bridge/cv_bridge.h>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <vector>

class ThreadPool {
public:
    ThreadPool(size_t threads);
    ~ThreadPool();
    void addTask(std::function<void()> func);

private:
    void worker();
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queueMutex;
    std::condition_variable condition;
    bool stop = false;
};

// === çº¿ç¨‹æ± å®ç° ===
ThreadPool::ThreadPool(size_t threads) {
    for (size_t i = 0; i < threads; ++i)
        workers.emplace_back([this] { worker(); });
}

void ThreadPool::worker() {
    while (true) {
        std::function<void()> task;
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            condition.wait(lock, [this] { return stop || !tasks.empty(); });
            if (stop && tasks.empty()) return;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();
    }
}

void ThreadPool::addTask(std::function<void()> func) {
    {
        std::lock_guard<std::mutex> lock(queueMutex);
        tasks.push(func);
    }
    condition.notify_one();
}

ThreadPool::~ThreadPool() {
    {
        std::unique_lock<std::mutex> lock(queueMutex);
        stop = true;
    }
    condition.notify_all();
    for (auto& t : workers)
        t.join();
}

// === ROS èŠ‚ç‚¹ç¤ºä¾‹ ===
class ImageProcessorNode {
public:
    ImageProcessorNode() : pool(4) {  // åˆ›å»º4çº¿ç¨‹çº¿ç¨‹æ± 
        ros::NodeHandle nh;
        sub = nh.subscribe("/camera/image_raw", 10, &ImageProcessorNode::imageCallback, this);
    }

    void imageCallback(const sensor_msgs::ImageConstPtr& msg) {
        // å¼‚æ­¥å¤„ç†å›¾åƒ
        pool.addTask([msg] {
            cv::Mat img = cv_bridge::toCvShare(msg, "bgr8")->image;
            cv::Mat gray;
            cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

            // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
            std::this_thread::sleep_for(std::chrono::milliseconds(100));

            ROS_INFO_STREAM("Processed frame in thread " << std::this_thread::get_id());
        });
    }

private:
    ros::Subscriber sub;
    ThreadPool pool;
};

int main(int argc, char** argv) {
    ros::init(argc, argv, "image_processor_node");
    ImageProcessorNode node;
    ros::spin();
    return 0;
}
```

---

### ğŸ§  ç¨‹åºé€»è¾‘åˆ†æ

| é˜¶æ®µ  | åŠ¨ä½œ           | è¯´æ˜                          |
| --- | ------------ | --------------------------- |
| 1ï¸âƒ£ | æ¥æ”¶åˆ°å›¾åƒå›è°ƒ      | `imageCallback` è¢« ROS ä¸»çº¿ç¨‹è°ƒç”¨ |
| 2ï¸âƒ£ | æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ±      | ä¸é˜»å¡ä¸»çº¿ç¨‹                      |
| 3ï¸âƒ£ | å·¥ä½œçº¿ç¨‹å¼‚æ­¥æ‰§è¡Œå›¾åƒå¤„ç† | å¹¶è¡Œå¤„ç†å¤šå¸§å›¾åƒ                    |
| 4ï¸âƒ£ | ä¸»çº¿ç¨‹ç»§ç»­ç›‘å¬æ–°æ¶ˆæ¯   | å®ç°é«˜å¹¶å‘ã€é«˜å®æ—¶æ€§                  |

---

## âš¡ å››ã€è¿è¡Œæ•ˆæœ

è¾“å‡ºç±»ä¼¼ï¼š

```
[INFO] [1691234567.123]: Processed frame in thread 140041735583488
[INFO] [1691234567.124]: Processed frame in thread 140041727190784
[INFO] [1691234567.125]: Processed frame in thread 140041718798080
...
```

ğŸ‘‰ æ¯ä¸ªä»»åŠ¡ç”±ä¸åŒçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œï¼Œä¸å†é˜»å¡å›è°ƒã€‚

---

## ğŸ§© äº”ã€ROS2 å¯¹åº”å†™æ³•ï¼ˆrclcpp + å¤šçº¿ç¨‹æ‰§è¡Œå™¨ï¼‰

åœ¨ ROS2 ä¸­ï¼Œä½ å¯ä»¥ï¼š

* ç›´æ¥ä½¿ç”¨ `rclcpp::executors::MultiThreadedExecutor`ï¼ˆå®˜æ–¹çº¿ç¨‹æ± ï¼‰
* æˆ–åµŒå…¥ä½ è‡ªå·±çš„çº¿ç¨‹æ± ç±»ï¼ˆå¦‚ä¸Š ThreadPoolï¼‰

ä¾‹å¦‚ï¼š

```cpp
rclcpp::executors::MultiThreadedExecutor exec;
auto node = std::make_shared<ImageProcessorNode>();
exec.add_node(node);
exec.spin(); // è‡ªåŠ¨å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå›è°ƒ
```

å¦‚æœè¦å®Œå…¨è‡ªå®šä¹‰ä»»åŠ¡è°ƒåº¦é€»è¾‘ï¼Œå¯ä»¥æŠŠä¸Šé¢çš„ `ThreadPool` æ”¾è¿› ROS2 èŠ‚ç‚¹ç±»å†…éƒ¨ï¼Œç”¨æ³•å‡ ä¹ä¸€è‡´ã€‚

---

## ğŸ’¡ å…­ã€å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨å»ºè®®

| æ¨¡å—               | ç”¨æ³•            |
| ---------------- | ------------- |
| æ„ŸçŸ¥ï¼ˆLidar/Cameraï¼‰ | ç”¨çº¿ç¨‹æ± å¼‚æ­¥å¤„ç†å¸§æ•°æ®   |
| æ§åˆ¶ç®—æ³•             | å¹¶è¡Œé¢„æµ‹è½¨è¿¹æˆ–é£é™©è¯„ä¼°   |
| åœ°å›¾æ„å»º             | å¤šçº¿ç¨‹ä¼˜åŒ–ï¼ˆå¦‚åç«¯ BAï¼‰ |
| AEB æµ‹è¯•å·¥å…·         | å¹¶è¡Œå›æ”¾ä¸åŒå·¥å†µä»¿çœŸæ•°æ®  |
| SLAM çœŸå€¼ç³»ç»Ÿ        | å¹¶è¡Œå¤„ç†æ ‡æ³¨ã€åæ ‡è½¬æ¢   |

---

## ğŸ” ä¸ƒã€ä¸‹ä¸€æ­¥å»ºè®®

ä½ ç°åœ¨å·²ç»èƒ½ï¼š
âœ… ç†è§£çº¿ç¨‹æ± åŸç†
âœ… æ‰‹å†™çº¿ç¨‹æ± 
âœ… åœ¨ ROS èŠ‚ç‚¹ä¸­åµŒå…¥ä½¿ç”¨

---

æ¥ä¸‹æ¥å¯ä»¥é€‰ä¸€ä¸ªæ–¹å‘æ·±å…¥ï¼š

1. **å¼ºåŒ–å®æˆ˜** â†’ æˆ‘å¸¦ä½ å†™ä¸€ä¸ªåœ¨ AEB æˆ– L2 åŠŸèƒ½æµ‹è¯•èŠ‚ç‚¹ä¸­ç”¨çº¿ç¨‹æ± åŠ é€Ÿä»¿çœŸçš„ä¾‹å­ï¼ˆçœŸå®å·¥ç¨‹é£æ ¼ï¼‰
2. **è¿›é˜¶æœºåˆ¶** â†’ å­¦ä¹ å¦‚ä½•åœ¨ ROS2 ä¸­æ•´åˆçº¿ç¨‹æ± ä¸ callback groupï¼ˆå›è°ƒç»„å¹¶å‘æ§åˆ¶ï¼‰

ğŸ‘‰ ä½ æƒ³æˆ‘å¸¦ä½ å¾€å“ªä¸ªæ–¹å‘ç»§ç»­ï¼Ÿ

---

## ç¬¬2éƒ¨åˆ† ros ä»£ç è§£æ

è¿™æ®µä»£ç å†™å¾—éå¸¸å¥½ ğŸ‘ï¼Œæ˜¯ä¸€ä¸ªå…¸å‹ã€å®ç”¨çš„ **ROS + è‡ªå®šä¹‰çº¿ç¨‹æ± å¼‚æ­¥å›¾åƒå¤„ç†** æ¡ˆä¾‹ã€‚
ä¸‹é¢æˆ‘å¸®ä½ ä»**æ•´ä½“åŠŸèƒ½ã€è¿è¡Œæœºåˆ¶ã€ä¼˜ç¼ºç‚¹å’Œæ”¹è¿›å»ºè®®**å››ä¸ªè§’åº¦åšä¸€ä¸ªå®Œæ•´è§£æã€‚

---

## ğŸ§© ä¸€ã€æ€»ä½“åŠŸèƒ½

è¿™æ®µç¨‹åºçš„ç›®çš„æ˜¯ï¼š

> âœ… ä» ROS è¯é¢˜ `/camera/image_raw` è®¢é˜…å›¾åƒ
> âœ… æ¯å¸§å›¾åƒä¸åœ¨å›è°ƒçº¿ç¨‹é‡Œå¤„ç†ï¼Œè€Œæ˜¯äº¤ç»™è‡ªå»ºçš„çº¿ç¨‹æ± å¼‚æ­¥æ‰§è¡Œ
> âœ… è¿™æ ·é¿å…å›¾åƒå›è°ƒè¢«è€—æ—¶æ“ä½œï¼ˆå¦‚ OpenCV è®¡ç®—ï¼‰å¡ä½

**å…³é”®ç‚¹ï¼š**

* ä½¿ç”¨ `ThreadPool` ç®¡ç†å¤šä¸ªåå°çº¿ç¨‹ï¼›
* ä½¿ç”¨ `std::queue<std::function<void()>>` ä¿å­˜ä»»åŠ¡ï¼›
* å›è°ƒä¸­åªè´Ÿè´£æ¨å…¥ä»»åŠ¡ï¼Œä¸åšè€—æ—¶å¤„ç†ï¼›
* æ¯ä¸ªä»»åŠ¡åœ¨çº¿ç¨‹æ± çº¿ç¨‹ä¸­ç‹¬ç«‹å¤„ç†å›¾åƒã€‚

---

## âš™ï¸ äºŒã€è¿è¡Œæœºåˆ¶åˆ†æ

è®©æˆ‘ä»¬æ‹†è§£ä¸€ä¸‹æ‰§è¡Œæµç¨‹ ğŸ‘‡

### 1ï¸âƒ£ å¯åŠ¨èŠ‚ç‚¹

```cpp
ImageProcessorNode node;
ros::spin();
```

* å¯åŠ¨ ROS è®¢é˜… `/camera/image_raw`ï¼›
* è¿›å…¥ `ros::spin()` é˜»å¡ç­‰å¾…å›è°ƒã€‚

---

### 2ï¸âƒ£ æ”¶åˆ°å›¾åƒæ¶ˆæ¯æ—¶

```cpp
void imageCallback(const sensor_msgs::ImageConstPtr& msg)
```

è¯¥å‡½æ•°åœ¨ **ROS å›è°ƒçº¿ç¨‹** ä¸­è¢«è°ƒç”¨ï¼ˆé»˜è®¤å•çº¿ç¨‹ï¼‰ã€‚

```cpp
pool.addTask([msg] {
    cv::Mat img = cv_bridge::toCvShare(msg, "bgr8")->image;
    cv::Mat gray;
    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    ROS_INFO_STREAM("Processed frame in thread " << std::this_thread::get_id());
});
```

è¿™é‡Œçš„å…³é”®ï¼š

* **ä¸ç›´æ¥å¤„ç†å›¾åƒ**ï¼›
* æŠŠå›¾åƒå¤„ç†é€»è¾‘å°è£…æˆ lambdaï¼›
* **æäº¤ç»™çº¿ç¨‹æ± å¼‚æ­¥æ‰§è¡Œ**ã€‚

è¿™æ ·ä¸»å›è°ƒå‡ ä¹ç«‹å³è¿”å› â†’ ä¸é˜»å¡ ROS æ¶ˆæ¯å¾ªç¯ã€‚

---

### 3ï¸âƒ£ çº¿ç¨‹æ± è°ƒåº¦

```cpp
addTask(func);
```

åšçš„äº‹æƒ…ï¼š

1. æŠŠä»»åŠ¡å‡½æ•°æ”¾å…¥ `tasks` é˜Ÿåˆ—ï¼›
2. é€šçŸ¥ä¸€ä¸ªçº¿ç¨‹é†’æ¥ã€‚

```cpp
condition.notify_one();
```

---

### 4ï¸âƒ£ å·¥ä½œçº¿ç¨‹æ‰§è¡Œä»»åŠ¡

```cpp
void ThreadPool::worker() {
    while (true) {
        std::function<void()> task;
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            condition.wait(lock, [this] { return stop || !tasks.empty(); });
            if (stop && tasks.empty()) return;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();  // å®é™…æ‰§è¡Œä»»åŠ¡
    }
}
```

æ¯ä¸ªå·¥ä½œçº¿ç¨‹å¾ªç¯ç­‰å¾…ä»»åŠ¡ï¼š

* è‹¥ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º â†’ ç¡çœ ï¼›
* è‹¥æœ‰ä»»åŠ¡ â†’ æ‹¿ä¸€ä¸ªå‡ºæ¥æ‰§è¡Œï¼›
* æ‰§è¡Œå®Œç»§ç»­å¾ªç¯ã€‚

å½“ç¨‹åºé€€å‡ºæ—¶ï¼Œææ„å‡½æ•°ä¼šå®‰å…¨åœ°ï¼š

* è®¾ç½® `stop = true`
* é€šçŸ¥æ‰€æœ‰çº¿ç¨‹é€€å‡º
* `join()` ç­‰å¾…ç»“æŸ

---

## ğŸ§  ä¸‰ã€ä¼˜ç‚¹æ€»ç»“

| ä¼˜ç‚¹           | è¯´æ˜                         |
| ------------ | -------------------------- |
| âœ… éé˜»å¡ ROS å›è°ƒ | å›¾åƒå›è°ƒä¸åšè€—æ—¶å¤„ç†ï¼Œä¸å µæ¶ˆæ¯é˜Ÿåˆ—          |
| âœ… å¹¶è¡Œå¤„ç†å¤šå¸§     | çº¿ç¨‹æ± å…è®¸å¤šå¸§åŒæ—¶å¤„ç†ï¼Œæå‡æ€§èƒ½           |
| âœ… å¯æ§çº¿ç¨‹æ•°é‡     | æ¯” OpenCV é»˜è®¤å¤šçº¿ç¨‹æˆ– async æ›´å¥½æ§åˆ¶ |
| âœ… å®‰å…¨å…³é—­æœºåˆ¶     | ææ„ä¸­è®¾ç½® `stop` å¹¶ `join`ï¼Œä¸ä¼šæ‚¬ç©º |

---

## âš ï¸ å››ã€å¯èƒ½çš„æ”¹è¿›å»ºè®®

### ğŸ’¡ 1ï¸âƒ£ æ§åˆ¶ä»»åŠ¡é˜Ÿåˆ—é•¿åº¦ï¼ˆé˜²æ­¢ backlogï¼‰

å¦‚æœå›¾åƒå¸§ç‡é«˜ã€å¤„ç†æ…¢ï¼Œä¼šå †ç§¯å¤§é‡ä»»åŠ¡ã€‚

å¯ä»¥åŠ ä¸ªé™åˆ¶ï¼š

```cpp
void ThreadPool::addTask(std::function<void()> func) {
    {
        std::lock_guard<std::mutex> lock(queueMutex);
        if (tasks.size() > 10) {
            ROS_WARN("Task queue full, dropping frame");
            return;  // ä¸¢å¸§ä»¥é˜²å¡ä½
        }
        tasks.push(func);
    }
    condition.notify_one();
}
```

---

### ğŸ’¡ 2ï¸âƒ£ è®©çº¿ç¨‹æ± æ”¯æŒè¿”å›å€¼ï¼ˆfutureï¼‰

å½“å‰ç‰ˆæœ¬åªæ‰§è¡Œä»»åŠ¡ï¼Œæ²¡æœ‰ç»“æœè¿”å›ã€‚

å¦‚æœå¸Œæœ›æ¯ä¸ªä»»åŠ¡èƒ½è¿”å›å¤„ç†ç»“æœï¼ˆä¾‹å¦‚æ£€æµ‹ç»“æœï¼‰ï¼Œ
å¯ä»¥ç”¨ `std::packaged_task` åŒ…è£…ä»»åŠ¡ï¼Œä½¿å…¶æ”¯æŒ `std::future`ï¼š

```cpp
template <typename F>
auto addTask(F&& func) -> std::future<decltype(func())> {
    using return_type = decltype(func());
    auto task = std::make_shared<std::packaged_task<return_type()>>(std::forward<F>(func));
    auto res = task->get_future();
    {
        std::lock_guard<std::mutex> lock(queueMutex);
        tasks.emplace([task]() { (*task)(); });
    }
    condition.notify_one();
    return res;
}
```

è¿™æ ·å°±èƒ½ï¼š

```cpp
auto future = pool.addTask([] { return computeSomething(); });
auto result = future.get();
```

---

### ğŸ’¡ 3ï¸âƒ£ æå‡å›¾åƒæ•°æ®å®‰å…¨æ€§

`cv_bridge::toCvShare()` è¿”å›çš„æ˜¯**å…±äº«æŒ‡é’ˆçš„å¼•ç”¨**ï¼Œ
å¦‚æœ ROS å›è°ƒè¿”å›å¤ªå¿«ï¼Œå›¾åƒå¯èƒ½è¢«é‡Šæ”¾ï¼ˆè™½ç„¶é€šå¸¸ä¸ä¼šï¼Œä½†æœ€å¥½æ³¨æ„ï¼‰ã€‚

æ›´å®‰å…¨çš„æ–¹å¼æ˜¯**æ‹·è´ä¸€ä»½æ•°æ®**ï¼š

```cpp
pool.addTask([img = cv_bridge::toCvCopy(msg, "bgr8")->image] {
    cv::Mat gray;
    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
    ...
});
```

---

### ğŸ’¡ 4ï¸âƒ£ è¾“å‡ºçº¿ç¨‹IDæ›´æ¸…æ™°

ä½ ç°åœ¨è¾“å‡ºï¼š

```cpp
ROS_INFO_STREAM("Processed frame in thread " << std::this_thread::get_id());
```

å¯ä»¥åŠ ä¸Š frame count æˆ–æ—¶é—´æˆ³æ–¹ä¾¿è°ƒè¯•ï¼š

```cpp
static std::atomic<int> frame_id = 0;
pool.addTask([msg, id = frame_id++] {
    ROS_INFO_STREAM("Processing frame #" << id
                    << " in thread " << std::this_thread::get_id());
});
```

---

## âœ… äº”ã€æ€»ç»“

| æ¨¡å—           | åŠŸèƒ½          | å…³é”®ç‚¹                        |
| ------------ | ----------- | -------------------------- |
| ThreadPool   | å¼‚æ­¥ä»»åŠ¡è°ƒåº¦      | condition_variable + queue |
| ROS callback | å¿«é€ŸæŠ•é€’ä»»åŠ¡      | ä¸é˜»å¡ ROS                    |
| OpenCV å¤„ç†    | å›¾åƒç°åº¦åŒ–       | æ¨¡æ‹Ÿè€—æ—¶ä»»åŠ¡                     |
| æ•´ä½“           | å¼‚æ­¥é«˜å¹¶å‘å›¾åƒå¤„ç†èŠ‚ç‚¹ | é«˜æ€§èƒ½ + å®‰å…¨å…³é—­                 |

---

å¦‚æœä½ æƒ³è®©è¿™ä¸ªèŠ‚ç‚¹ï¼š

* æ”¯æŒ**ä»»åŠ¡ç»“æœè¿”å›**ï¼ˆæ¯”å¦‚æ¨ç†è¾“å‡ºï¼‰ï¼›
* æˆ–è€…æ”¯æŒ**æŒ‰å›¾åƒæ—¶é—´æˆ³é¡ºåºè¾“å‡ºç»“æœ**ï¼›
* æˆ–è€…**ç»Ÿè®¡æ¯å¸§å¤„ç†æ—¶é—´ã€FPS**ï¼›

æˆ‘å¯ä»¥å¸®ä½ ç›´æ¥æ‰©å†™æˆä¸€ä¸ª**â€œå¯æµ‹æ€§èƒ½çš„å¤šçº¿ç¨‹å›¾åƒå¤„ç†èŠ‚ç‚¹â€**æ¨¡æ¿ã€‚

è¦æˆ‘å¸®ä½ æ”¹é€ æˆé‚£ç§ç‰ˆæœ¬å—ï¼Ÿ

---

## ç¬¬ä¸‰éƒ¨åˆ† ç»“æœè¿”å›

éå¸¸å¥½çš„é—®é¢˜ ğŸ‘
ç°åœ¨ä½ å·²ç»å®Œæˆäº†çº¿ç¨‹æ± å¼‚æ­¥å›¾åƒå¤„ç†çš„æ ¸å¿ƒéƒ¨åˆ†ï¼ˆå¹¶è¡Œå¤„ç†ï¼‰ï¼Œ
æ¥ä¸‹æ¥è¦è§£å†³çš„æ˜¯ **â€œå›¾åƒå¤„ç†å®Œä¹‹åï¼Œå¦‚ä½•ä½¿ç”¨ç»“æœâ€**ã€‚

è¿™ä¸ªé—®é¢˜åˆ†ä¸ºä¸‰ç§å…¸å‹åœºæ™¯ğŸ‘‡
æˆ‘å¸®ä½ æŒ‰ç”¨é€”è®²æ¸…æ¥šæ¯ç§å†™æ³•è¯¥æ€ä¹ˆåšï¼ˆå¸¦ä»£ç ï¼‰ã€‚

---

## ğŸ§© ä¸€ã€å½“å‰ä»£ç å›é¡¾

ä½ çš„æ ¸å¿ƒå›è°ƒæ˜¯è¿™æ ·çš„ï¼š

```cpp
void imageCallback(const sensor_msgs::ImageConstPtr& msg) {
    pool.addTask([msg] {
        cv::Mat img = cv_bridge::toCvShare(msg, "bgr8")->image;
        cv::Mat gray;
        cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        ROS_INFO_STREAM("Processed frame in thread " << std::this_thread::get_id());
    });
}
```

ç›®å‰ä»»åŠ¡æ‰§è¡Œå®Œåªæ˜¯æ‰“å°æ¶ˆæ¯ï¼Œä½†æ²¡æœ‰â€œè¾“å‡ºç»“æœâ€ã€‚
æ‰€ä»¥â€œå›¾åƒå¤„ç†å¥½äº†è¯¥å¦‚ä½•ä½¿ç”¨â€ï¼Œå–å†³äºä½ è¦**åšä»€ä¹ˆæ ·çš„è¾“å‡º**ğŸ‘‡

---

## âœ… åœºæ™¯ 1ï¼šå¤„ç†åå‘å¸ƒæ–°å›¾åƒï¼ˆæœ€å¸¸è§ï¼‰

> åœºæ™¯ï¼šä½ æƒ³æŠŠå¤„ç†åçš„å›¾åƒé‡æ–°å‘å¸ƒæˆ ROS è¯é¢˜ï¼Œæ¯”å¦‚ `/image_gray`ã€‚

### æ”¹æ³•ï¼š

åœ¨ç±»ä¸­å¢åŠ ä¸€ä¸ª `ros::Publisher`ï¼Œç„¶ååœ¨ä»»åŠ¡ä¸­å‘å¸ƒã€‚

```cpp
class ImageProcessorNode {
public:
    ImageProcessorNode() : pool(4) {
        ros::NodeHandle nh;
        sub = nh.subscribe("/camera/image_raw", 10, &ImageProcessorNode::imageCallback, this);
        pub = nh.advertise<sensor_msgs::Image>("/image_gray", 10);
    }

    void imageCallback(const sensor_msgs::ImageConstPtr& msg) {
        pool.addTask([this, msg] {
            cv::Mat img = cv_bridge::toCvCopy(msg, "bgr8")->image;
            cv::Mat gray;
            cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

            // è½¬å› ROS æ¶ˆæ¯
            sensor_msgs::ImagePtr out_msg = cv_bridge::CvImage(
                msg->header, "mono8", gray
            ).toImageMsg();

            // å‘å¸ƒç»“æœ
            pub.publish(out_msg);
            ROS_INFO_STREAM("Published processed frame from thread " << std::this_thread::get_id());
        });
    }

private:
    ros::Subscriber sub;
    ros::Publisher pub;
    ThreadPool pool;
};
```

### âœ… æ•ˆæœ

* è¾“å…¥ `/camera/image_raw`ï¼›
* è¾“å‡º `/image_gray`ï¼›
* ä¸»çº¿ç¨‹ä¸ä¼šå¡é¡¿ï¼›
* å›¾åƒæŒ‰å¼‚æ­¥çº¿ç¨‹å®Œæˆåå‘å¸ƒã€‚

---

## âœ… åœºæ™¯ 2ï¼šè¦è¿”å›è®¡ç®—ç»“æœï¼ˆæ•°å€¼ã€æ£€æµ‹æ¡†ç­‰ï¼‰

> åœºæ™¯ï¼šæ¯”å¦‚ä½ åœ¨å›¾åƒä¸­æ£€æµ‹äº†ç‰©ä½“ï¼Œæƒ³æŠŠæ£€æµ‹ç»“æœäº¤å›ä¸»çº¿ç¨‹æˆ–é€»è¾‘å±‚ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ éœ€è¦è®©çº¿ç¨‹æ± ä»»åŠ¡æœ‰â€œè¿”å›å€¼â€ï¼Œ
ä¹Ÿå°±æ˜¯ä½¿ç”¨ **`std::future`**ï¼ˆé€šè¿‡ `std::packaged_task`ï¼‰ã€‚

### æ”¹è¿› `ThreadPool`ï¼ˆæ”¯æŒè¿”å›å€¼ï¼‰

æŠŠä½ çš„ `ThreadPool::addTask()` æ”¹æˆæ¨¡æ¿ï¼š

```cpp
class ThreadPool {
public:
    ...
    template <class F, class... Args>
    auto addTask(F&& f, Args&&... args)
        -> std::future<typename std::invoke_result<F, Args...>::type>;
};

template <class F, class... Args>
auto ThreadPool::addTask(F&& f, Args&&... args)
    -> std::future<typename std::invoke_result<F, Args...>::type> {
    using return_type = typename std::invoke_result<F, Args...>::type;

    auto task = std::make_shared<std::packaged_task<return_type()>>(
        std::bind(std::forward<F>(f), std::forward<Args>(args)...)
    );

    std::future<return_type> res = task->get_future();

    {
        std::lock_guard<std::mutex> lock(queueMutex);
        tasks.emplace([task]() { (*task)(); });
    }
    condition.notify_one();
    return res;
}
```

---

### ä½¿ç”¨ï¼šå¼‚æ­¥è®¡ç®— + ç­‰å¾…ç»“æœ

```cpp
void imageCallback(const sensor_msgs::ImageConstPtr& msg) {
    auto future = pool.addTask([msg] {
        cv::Mat img = cv_bridge::toCvCopy(msg, "bgr8")->image;
        cv::Mat gray;
        cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
        return cv::mean(gray)[0]; // è¿”å›å¹³å‡äº®åº¦
    });

    // å¯ä»¥ç¨ååœ¨ä¸»çº¿ç¨‹é‡Œç­‰ç»“æœï¼ˆæˆ–éé˜»å¡ç­‰å¾…ï¼‰
    auto avg_brightness = future.get(); // é˜»å¡ç­‰å¾…ç»“æœ
    ROS_INFO_STREAM("å¹³å‡äº®åº¦: " << avg_brightness);
}
```

ğŸ§  å¦‚æœä¸æƒ³é˜»å¡ä¸»çº¿ç¨‹ï¼Œä¹Ÿå¯ä»¥ç”¨ `future.wait_for(0ms)` å¾ªç¯è½®è¯¢ã€‚

---

## âœ… åœºæ™¯ 3ï¼šä»»åŠ¡å®Œæˆåæ‰§è¡Œå›è°ƒï¼ˆéé˜»å¡ï¼‰

> åœºæ™¯ï¼šä½ ä¸éœ€è¦ç«‹å³ç”¨ç»“æœï¼Œåªæƒ³â€œä»»åŠ¡å®Œæˆåè‡ªåŠ¨æ‰§è¡ŒæŸä¸ªå›è°ƒâ€ã€‚

å¯ä»¥å°è£…æˆâ€œå®Œæˆå›è°ƒâ€çš„å†™æ³•ï¼š

```cpp
template <typename F, typename Callback>
void addTaskWithCallback(F&& func, Callback&& cb) {
    pool.addTask([func = std::forward<F>(func), cb = std::forward<Callback>(cb)] {
        auto result = func();
        cb(result);
    });
}
```

ä½¿ç”¨ï¼š

```cpp
addTaskWithCallback(
    [msg] {
        cv::Mat img = cv_bridge::toCvCopy(msg, "bgr8")->image;
        cv::Mat gray;
        cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
        return cv::mean(gray)[0];
    },
    [](double avg_brightness) {
        ROS_INFO_STREAM("å¼‚æ­¥å®Œæˆ! å¹³å‡äº®åº¦: " << avg_brightness);
    }
);
```

è¿™ç§å†™æ³•éå¸¸ä¼˜é›…ï¼š
ä»»åŠ¡æ‰§è¡Œå®Œåç«‹å³è§¦å‘å›è°ƒï¼Œæ— éœ€ `future.get()`ã€‚

---

## âœ… å››ã€å¦‚æœä½ æƒ³åœ¨ GUI æˆ–å…¶ä»–ç³»ç»Ÿä¸­ä½¿ç”¨

åœ¨é ROS çš„åœºæ™¯ä¸­ï¼Œæ¯”å¦‚ä½ è¦ï¼š

* åœ¨çª—å£ä¸­æ˜¾ç¤ºç»“æœï¼›
* å°†å¤„ç†åçš„å›¾åƒä¼ å…¥å¦ä¸€ä¸ªç®—æ³•çº¿ç¨‹ï¼›
* æˆ–è€…å­˜å…¥é˜Ÿåˆ—ä¾›åç»­æ¨¡å—æ¶ˆè´¹ï¼›

åŒæ ·å¯ä»¥åœ¨ä»»åŠ¡å†…éƒ¨æˆ–è€…å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œï¼Œä¾‹å¦‚ï¼š

```cpp
pool.addTask([this, msg] {
    cv::Mat img = cv_bridge::toCvCopy(msg, "bgr8")->image;
    cv::Mat edges;
    cv::Canny(img, edges, 50, 150);

    {
        std::lock_guard<std::mutex> lock(displayMutex);
        lastProcessedFrame = edges.clone();
    }
});
```

ä¹‹åä½ å¯ä»¥åœ¨ä¸»å¾ªç¯ä¸­ä½¿ç”¨ `lastProcessedFrame` è¿›è¡Œæ˜¾ç¤ºæˆ–åˆ†æã€‚

---

## âœ… äº”ã€æ€»ç»“è¡¨æ ¼

| åœºæ™¯     | æ–¹æ³•               | æ˜¯å¦é˜»å¡ | ç”¨é€”        |
| ------ | ---------------- | ---- | --------- |
| å‘å¸ƒå›¾åƒ   | `ros::Publisher` | å¦    | è¾“å‡ºå¤„ç†åå›¾åƒ   |
| è¿”å›æ•°å€¼ç»“æœ | `std::future`    | å¯æ§   | è®¡ç®—ç»“æœã€æ£€æµ‹è¾“å‡º |
| å›è°ƒå¼é€šçŸ¥  | è‡ªå®šä¹‰å›è°ƒ            | å¦    | éé˜»å¡å¼‚æ­¥åé¦ˆ   |
| å­˜å…¥å…±äº«å˜é‡ | mutex + æˆå‘˜å˜é‡     | å¦    | åç»­ç®—æ³•ä½¿ç”¨    |

---

å¦‚æœä½ å‘Šè¯‰æˆ‘ï¼š

> â€œæˆ‘å¸Œæœ›å¤„ç†å®Œå›¾åƒååšä»€ä¹ˆï¼Ÿâ€
> æ¯”å¦‚ï¼š

* å‘å¸ƒç°åº¦å›¾ï¼›
* å‘å¸ƒç‰©ä½“æ£€æµ‹ç»“æœï¼›
* æˆ–è€…è¿”å›ç»™å¦ä¸€ä¸ª ROS èŠ‚ç‚¹ï¼›

æˆ‘å¯ä»¥å¸®ä½ è¡¥å…¨å¯¹åº”çš„å®Œæ•´ä»£ç æ¨¡æ¿ï¼ˆåŒ…æ‹¬ ROS Publisher / service / callback æ¨¡å¼ï¼‰ã€‚

ğŸ‘‰ ä½ å¸Œæœ›å¤„ç†å¥½çš„å›¾åƒæˆ–ç»“æœè¢«æ€ä¹ˆç”¨ï¼Ÿ

