```cpp
#pragma once

#include <iostream>
#include <algorithm>
#include <string>
#include <memory>
#include <map>
#include <sys/stat.h>
#include <sys/types.h>
#include "L2_FC120PercStruct.h"
#include "NetWork/DispatchUdpEchoServer.h"
#include "configParser.h"
#include "ipc/channel_interface.h"
#include "framework/runtime.h"
#include <unordered_map>
#include "BaseConfig.h"
#include "viewtoolTimer.h"
using namespace faw::ad::ipc;
using namespace faw::adas::ViewTool;
using namespace faw::adas;
namespace faw
{
	namespace adas
	{
		namespace ViewTool
		{
			using READER_CALLBACK = std::function<void(std::string &channelname, faw::ad::ipc::ChannelReader *reader)>;
			class ChannelDataDispatch
			{
			public:
				ChannelDataDispatch(std::shared_ptr<faw::adas::ViewTool::DispatchUdpEchoServer> ServerPara,
									std::shared_ptr<faw::adas::ViewTool::configParser> configpara,
									faw::ad::framework::LoggerT *loggerPara)
					: Server(ServerPara),
					  config(configpara),
					  loggerP(loggerPara)
				{
					InitChannel();
					Sf_LaneInfoSyncIndex = 0;
					laneInfoTimeStamp = 0.0;
					InitTimer();
				}

				~ChannelDataDispatch()
				{
					Reader_list_.clear();
					Reader_Vehicle_list_.clear();
				}

				void InitChannel()
				{
					Reader_list_.clear();
					Reader_Vehicle_list_.clear();
					std::cout << "InitChannel " << std::endl;
					std::cout << "FawGlobalResources " << std::endl;
					// 定义报文订阅回调
					// READER_CALLBACK callback = std::bind(&ChannelDataDispatch::Recv_Callback, this, std::placeholders::_1, std::placeholders::_2,std::placeholders::_3);
					const map<string, packageConfig> packageConfig = config->getPackageMap();
					std::cout << "InitChannel package Config count:" << packageConfig.size() << std::endl;
					auto itr = packageConfig.begin();
					while (itr != packageConfig.end())
					{
						if (itr->second.bregister)
						{
							faw::ad::ipc::ChannelInfo channel_info;
							channel_info.ChannelName(itr->second.strName);
							channel_info.TransportType((faw::ad::ipc::ChannelType)itr->second.channel_type);
							std::cout << "channel Name : " << itr->second.strName << std::endl;
							PackagetIDEnum channelId = PackageNameAndIDTransfer::getPacakageIDByName(itr->second.strName);
							int max_msg_size = 0;
							if (itr->second.msg_size > 0)
							{
								max_msg_size = itr->second.msg_size;
							}
							else
							{
								max_msg_size = PackageNameAndIDTransfer::getPackageSize(channelId);
							}
							std::cout << "channel ID : " << channelId << std::endl;
							std::cout << "channel MaxMessageSize : " << max_msg_size << std::endl;

							channel_info.TransPortQos().MaxMessageSize(max_msg_size);
							channel_info.TransPortQos().QueueSize(itr->second.queue_size);

							if (channelId == CycleEPSWhlAngleID || channelId == CycleSpeedValveID || channelId == CycleYawRateSensorID || channelId == CycleIMUDataID || channelId == CycleSpeedFCID || channelId == CycleYawRateOriID || 
								channelId == VehicleHeightID || channelId == RearWheelSteeringID)
							{
								auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info);
								Reader_Vehicle_list_.insert(std::make_pair(itr->second.strName, reader));
							}
							else if (channelId == OTS_Sf_SensorFrameMessageID)
							{
								auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info);
								Reader_Radar_list_.insert(std::make_pair(itr->second.strName, reader));
							}
							else if (channelId == SI_Sf_VM_L2_AEBControlID || channelId == SI_Sf_VM_L2_AEBHMIConrolID || channelId == SI_Sf_VM_L0_Warning_RearID || channelId == SI_Sf_VM_L2_AEBHMIConrol_OverseasID ||
									 channelId == Sf_VM_ADL2_L2DrivingControl_OverseasID || channelId == SI_Sf_VM_L2_RAEBHMIConrol_OverseasID)
							{
								auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info);
								Reader_AEB_list_.insert(std::make_pair(itr->second.strName, reader));
							}
							else if (channelId == H264DataID)
							{
								CallbackType callback = std::bind(&ChannelDataDispatch::Recv_Callback, this, itr->second.strName, std::placeholders::_1, false);
								auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info, callback);
								Reader_list_.insert(std::make_pair(itr->second.strName, reader));
							}
							else
							{
								CallbackType callback = std::bind(&ChannelDataDispatch::Recv_Callback, this, itr->second.strName, std::placeholders::_1, false);
								auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info, callback);
								// auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info);
								Reader_list_.insert(std::make_pair(itr->second.strName, reader));
							}
						}
						// if (config->getStartReplayModel() && itr->second.bregister)
						// {
						// 	faw::ad::ipc::ChannelInfo channel_info;
						// 	channel_info.ChannelName(itr->second.strName + "_Replay");
						// 	channel_info.TransportType((faw::ad::ipc::ChannelType)itr->second.channel_type);
						// 	std::cout << "channel Name : " << itr->second.strName + "_Replay" << std::endl;
						// 	std::cout << "channel MaxMessageSize : " << PackageNameAndIDTransfer::getPackageSize(PackageNameAndIDTransfer::getPacakageIDByName(itr->second.strName)) << std::endl;
						// 	channel_info.TransPortQos().MaxMessageSize(PackageNameAndIDTransfer::getPackageSize(PackageNameAndIDTransfer::getPacakageIDByName(itr->second.strName)));
						// 	channel_info.TransPortQos().QueueSize(itr->second.queue_size);
						// 	CallbackType callback = std::bind(&ChannelDataDispatch::Recv_Callback, this, itr->second.strName, std::placeholders::_1);
						// 	auto reader = faw::ad::ipc::Channel::Instance()->CreateReader(channel_info, callback);
						// 	Reader_list_.insert(std::make_pair(itr->second.strName + "_Replay", reader));
						// }
						itr++;
					}
					std::cout << "Reader_list_ size: " << Reader_list_.size() << std::endl;

					m_getVehicleDataThr = std::thread(&ChannelDataDispatch::GetVehicleDataFunc, this);
					m_getVehicleDataThr.detach();
					m_getRadarDataThr = std::thread(&ChannelDataDispatch::GetRadarDataFunc, this);
					m_getRadarDataThr.detach();
					m_getAEBDataThr = std::thread(&ChannelDataDispatch::GeAEBDataFunc, this);
					m_getAEBDataThr.detach();
				}

				void GetVehicleDataFunc()
				{
					while (true)
					{
						std::this_thread::sleep_for(std::chrono::milliseconds(70));
						for (auto &readerEle : Reader_Vehicle_list_)
						{
							std::string channelName = readerEle.first;
							Recv_Callback(channelName, readerEle.second.get(), true);
						}
					}
				}

				void GetPecFusRadDataFunc()
				{
					while (true)
					{
						std::this_thread::sleep_for(std::chrono::milliseconds(40));
						for (auto &readerEle : Reader_list_)
						{
							std::string channelName = readerEle.first;
							Recv_Callback(channelName, readerEle.second.get(), false);
						}
					}
				}

				void GetRadarDataFunc()
				{
					while (true)
					{
						std::this_thread::sleep_for(std::chrono::milliseconds(40));
						for (auto &readerEle : Reader_Radar_list_)
						{
							std::string channelName = readerEle.first;
							Recv_Callback(channelName, readerEle.second.get(), true);
						}
					}
				}

				void GeAEBDataFunc()
				{
					while (true)
					{
						std::this_thread::sleep_for(std::chrono::milliseconds(50));
						for (auto &readerEle : Reader_AEB_list_)
						{
							std::string channelName = readerEle.first;
							Recv_Callback(channelName, readerEle.second.get(), true);
						}
					}
				}

				void InitTimer()
				{
					TimerWheel& timer = TimerWheel::GetTimerInstance();
					timer.AddTask(1000,[this](){PrintSignalsFrames();});
					timer.Start();
				}
				void PrintSignalsFrames()
				{
					static int count = 0;
					if (count % 5 == 0)
					{
						// std::cout << std::endl;
						loggerP->LogDebug() << "Pec sfm: " << m_statistic[PackagetIDEnum::Sf_SensorFrameMessageID] << ", Pec lane: " << m_statistic[PackagetIDEnum::Sf_LaneInfoID]
											<< ", Pec obj: " << m_statistic[PackagetIDEnum::Sf_ObjectInfoID] << ", Pec stop: " << m_statistic[PackagetIDEnum::Sf_StopLineID]
											<< ", Pec tsr: " << m_statistic[PackagetIDEnum::Sf_TSRID] << ", Pec rm: " << m_statistic[PackagetIDEnum::Sf_RMID]
											<< ", Pec edg: " << m_statistic[PackagetIDEnum::Sf_EDGInfoID] << ", Pec obs: " << m_statistic[PackagetIDEnum::Sf_ObstacleID]
											<< ", Pec einfo: " << m_statistic[PackagetIDEnum::IDT_Sf_EInfoID] << ", Pec traffic: " << m_statistic[PackagetIDEnum::Sf_TrafficLightID]
											<< ", Pec adb: " << m_statistic[PackagetIDEnum::Sf_ADBID] << ", Pec ihc: " << m_statistic[PackagetIDEnum::Sf_IHCID]
											<< ", Pec DTC: " << m_statistic[PackagetIDEnum::Sf_DTCID] << ", Pec MeterData_MergeInfo " << m_statistic[PackagetIDEnum::HazardWarning_LampRequestID];
					}
					else if (count % 5 == 1)
					{
						// std::cout << std::endl;
						loggerP->LogDebug() << "Fus obj: " << m_statistic[PackagetIDEnum::OTS_Sf_ObjectInfoID] << ", Radar: " << m_statistic[PackagetIDEnum::OTS_Sf_SensorFrameMessageID]
											<< ", Fus tsr: " << m_statistic[PackagetIDEnum::OTS_Sf_TSRID] << ", Fus rm: " << m_statistic[PackagetIDEnum::OTS_Sf_RMID]
											<< ", Fus lane: " << m_statistic[PackagetIDEnum::OTS_Sf_LaneInfoID] << ", Fus edg: " << m_statistic[PackagetIDEnum::OTS_Sf_EDGInfoID]
											<< ", Fus einfo: " << m_statistic[PackagetIDEnum::OTS_IDT_Sf_EInfoID] << ", Fus traffic: " << m_statistic[PackagetIDEnum::OTS_Sf_TrafficLightID]
											<< ", Fus adb: " << m_statistic[PackagetIDEnum::OTS_Sf_ADBID] << ", Fus ihc: " << m_statistic[PackagetIDEnum::OTS_Sf_IHCID]
											<< ", Fus stop: " << m_statistic[PackagetIDEnum::OTS_Sf_FPS_StoplineID] << ", Fus obs: " << m_statistic[PackagetIDEnum::OTS_Sf_ObstacleID];
					}
					else if (count % 5 == 2)
					{
						// std::cout << std::endl;
						loggerP->LogDebug() << "Veh IMU: " << m_statistic[PackagetIDEnum::CycleIMUDataID] << ", Veh EPS: " << m_statistic[PackagetIDEnum::CycleEPSWhlAngleID]
											<< ", Veh speed: " << m_statistic[PackagetIDEnum::CycleSpeedValveID] << ", Veh YawRate: " << m_statistic[PackagetIDEnum::CycleYawRateSensorID]
											<< ", Veh speedFC: " << m_statistic[PackagetIDEnum::CycleSpeedFCID] << ", Veh YawRateOri: " << m_statistic[PackagetIDEnum::CycleYawRateOriID]
											<< ", Veh VehicleHeight: " << m_statistic[PackagetIDEnum::VehicleHeightID] << ", Veh RearWheelSteering: " << m_statistic[PackagetIDEnum::RearWheelSteeringID];
					}
					else if (count % 5 == 3)
					{
						// std::cout << std::endl;
						loggerP->LogDebug() << "MCU emaStatus: " << m_statistic[PackagetIDEnum::Sf_VM_L2_EMAStatusID] << ", MCU aebhmi: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L2_AEBHMIConrolID]
											<< ", MCU warnfront: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L0_Warning_FrontID] << ", MCU warnrear: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L0_Warning_RearID]
											<< ", MCU chascontrol: " << m_statistic[PackagetIDEnum::Sf_VM_ADL2_ChasControlID] << ", MCU drivcontrol: " << m_statistic[PackagetIDEnum::Sf_VM_ADL2_L2DrivingControlID]
											<< ", MCU aebcontrol: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L2_AEBControlID] << ", MCU hazard: " << m_statistic[PackagetIDEnum::HazardWarning_LampRequestID];
					}
					else
					{
						std::cout << std::endl;
						loggerP->LogDebug() << "Overseas AEBHMIConrol_Overseas: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L2_AEBHMIConrol_OverseasID] 
											<< ", Overseas L2DrivingControl_Overseas: " << m_statistic[PackagetIDEnum::Sf_VM_ADL2_L2DrivingControl_OverseasID]
											<< ", Overseas RAEBHMIConrol_Overseas: " << m_statistic[PackagetIDEnum::SI_Sf_VM_L2_RAEBHMIConrol_OverseasID];
						std::cout << std::endl;
					}
					count++;
				}

				void Recv_Callback(std::string &channelname, faw::ad::ipc::ChannelReader *reader, bool merge)
				{
					std::vector<std::shared_ptr<faw::ad::ipc::ChannelBuffer>> buffer_list;
					faw::ad::ipc::eFawCMRstCode ret = reader->GetUnReadData(buffer_list);
					// std::cout << "[Recv_Callback] channelname is " << channelname << std::endl;
					if (ret == faw::ad::ipc::eFawCMRstCode::FAW_CM_QUEUE_EMPTY)
					{
						// std::cout << "reader empty queue" << std::endl;
						return;
					}
					// std::cout << "buffer_list.size() :" << buffer_list.size() << std::endl;
					if (merge)
					{
						PackagetIDEnum packageID = PackageNameAndIDTransfer::getPacakageIDByName(channelname);
						if (packageID != PackagetIDEnum::Sf_NonePackageNameID)
						{
							std::vector<char *> data;
							for (int16_t i = buffer_list.size() - 1; i >= 0; --i)
							// for (uint16_t i = 0; i < buffer_list.size(); ++i)
							{
								std::string fileName = "";
								if (nullptr == buffer_list[i])
								{
									std::cout << "buffer_list[i] nullptr, i = " << i << std::endl;
									continue;
								}
								data.push_back((char *)(buffer_list[i]->Data()));
								m_statistic[packageID]++;
							}
							// std::cout << "[Send] channelname is " << channelname << std::endl;
							Server->sendPackage(packageID, PackageNameAndIDTransfer::getPackageSize(packageID), data);
						}
					}
					else
					{
						for (int16_t i = buffer_list.size() - 1; i >= 0; --i)
						{
							std::string fileName = "";
							if (nullptr == buffer_list[i])
							{
								std::cout << "buffer_list[i] nullptr, i = " << i << std::endl;
								continue;
							}

							if (Server.get())
							{
								PackagetIDEnum packageID = PackageNameAndIDTransfer::getPacakageIDByName(channelname);
								if (packageID != PackagetIDEnum::Sf_NonePackageNameID)
								{
									// std::cout << "[Send] channelname is " << channelname << std::endl;
									if (packageID == PackagetIDEnum::H264DataID)
									{
										Server->sendPackage((char*)(buffer_list[i]->Data()), buffer_list[i]->Size());
									}
									else
										Server->sendPackage(packageID, PackageNameAndIDTransfer::getPackageSize(packageID), (char *)(buffer_list[i]->Data()));
									m_statistic[packageID]++;
								}
							}

							// if (config->getSaveDataToFileSign())
							// {
							// 	PackagetIDEnum packageID = PackageNameAndIDTransfer::getPacakageIDByName(channelname);
							// 	if (packageID != PackagetIDEnum::Sf_NonePackageNameID)
							// 	{
							// 		std::string dirPath = std::getenv("Data_Visualization");
							// 		dirPath = dirPath + "/data/saveData/" + channelname + "/";
							// 		if (!isFileExists_stat(dirPath))
							// 			mkpath(dirPath);
							// 		if (!fileName.empty())
							// 		{
							// 			std::string finalfileName = dirPath + fileName;
							// 			writeDataToFile(buffer_list[i]->Data(), PackageNameAndIDTransfer::getPackageSize(packageID), finalfileName);
							// 		}
							// 	}
							// }
						}
					}
				}

				static bool isFileExists_stat(string &name)
				{
					struct stat buffer;
					return (stat(name.c_str(), &buffer) == 0);
				}

				static int mkpath(std::string s, mode_t mode = 0755)
				{
					size_t pre = 0, pos;
					std::string dir;
					int mdret;

					if (s[s.size() - 1] != '/')
					{
						// force trailing / so we can handle everything in loop
						s += '/';
					}

					while ((pos = s.find_first_of('/', pre)) != std::string::npos)
					{
						dir = s.substr(0, pos++);
						pre = pos;
						if (dir.size() == 0)
							continue; // if leading / first time is 0 length
						if ((mdret = ::mkdir(dir.c_str(), mode)) && errno != EEXIST)
						{
							return mdret;
						}
					}
					return mdret;
				}

				void writeDataToFile(void *data, int size, const std::string &strFilePath)
				{
					FILE *fp = fopen(strFilePath.c_str(), "wb");
					if (!fp)
					{
						std::cout << "Unable open file :" << strFilePath << std::endl;
						return;
					}
					fwrite(data, 1, size, fp);
					fflush(fp);
					fclose(fp);
				}

			private:
				// void simpleRadarSensorFrameMessage(const faw::adas::Sf_VCo_L2_DrivingSenFus::Sf_SensorFrameMessage_struct &sVeh, faw::adas::ViewTool::simpleSf_SensorFrameMessage_struct &result)
				// {
				// 	result.Sf_Timestamp_double = sVeh.Sf_Timestamp_double;
				// 	result.Sf_SensorId_enum = sVeh.Sf_SensorId_enum;
				// 	for (int index = 0; index < 64; index++)
				// 	{
				// 		result.Sf_Object_array[index].Sf_IsValid_bool = sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_IsValid_bool;
				// 		memcpy(result.Sf_Object_array[index].Sf_Polygon_array, sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_Polygon_array, sizeof(Sf_Point3D_struct) * 8);
				// 		result.Sf_Object_array[index].Sf_TrackId_int = sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_TrackId_int;
				// 		result.Sf_Object_array[index].Sf_Confidence_float = sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_Confidence_float;
				// 		result.Sf_Object_array[index].Sf_LatestTrackedTime_double = sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_LatestTrackedTime_double;
				// 		result.Sf_Object_array[index].Sf_Type_enum = sVeh.Sf_Frame_struct.Sf_Object_array[index].Sf_Type_enum;
				// 	}
				// }

			private:
				std::map<std::string, std::shared_ptr<faw::ad::ipc::ChannelReader>> Reader_list_;		  // ！注册的channel列表
				std::map<std::string, std::shared_ptr<faw::ad::ipc::ChannelReader>> Reader_Vehicle_list_; // ！注册的车身信号channel列表
				std::map<std::string, std::shared_ptr<faw::ad::ipc::ChannelReader>> Reader_Radar_list_;	  // ！注册雷达信号channel列表
				std::map<std::string, std::shared_ptr<faw::ad::ipc::ChannelReader>> Reader_AEB_list_;	  // ！注册AEB信号channel列表
				std::shared_ptr<faw::adas::ViewTool::DispatchUdpEchoServer> Server;						  // socket通信发送服务端
				std::shared_ptr<faw::adas::ViewTool::configParser> config;								  //! 配置解析器
				std::mutex replayerContainerMutex_;
				int Sf_LaneInfoSyncIndex;
				double laneInfoTimeStamp;
				std::thread m_getVehicleDataThr;
				std::thread m_getRadarDataThr;
				std::thread m_getAEBDataThr;
				std::unordered_map<int, uint64_t> m_statistic;
				// Timer::Ptr m_timer;
				faw::ad::framework::LoggerT *loggerP;
			};
		} // namespace framework
	}	  // namespace adas
} // namespace faw
```