明白，你不是问 *header-only 库怎么写*，而是想问：

👉 **“在写 C++ 头文件-only 代码时，编程上应该注意什么问题？”**
也就是写法、编码习惯、设计上的坑点。

我把 **实战中最关键、最容易犯错的注意事项** 系统地整理如下：

---

# ✅ Header-only 编程需要注意的问题（从开发视角出发）

以下内容不讲理论，讲实际会踩坑的点，都是工程中真实会遇到的。

---

# 1. **保证每个可执行符号只有一个定义（避免重复定义）**

Header-only 中最容易犯错的就是重复定义：

### ❌ 不要在头文件中放普通函数或全局变量

```cpp
int g_x = 0;        // 错误：多个 cpp 会重复定义
void foo() {...}    // 错误：普通函数不是 inline
```

### ✔ 解决办法：加 inline 或模板化

```cpp
inline int g_x = 0;
inline void foo() {...}
```

---

# 2. **避免 include 过多 —— 头文件爆炸 & 编译变慢**

因为 header-only 每一处 include 都会重新编译。

### ❌ 不要乱 include

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <thread>
```

### ✔ 推荐的做法

* 如果你只用到类型声明 → 使用前向声明
* 能延迟 include 的放到用户 cpp 中再 include
* 尽量将不必要的依赖写在尾部，减少 cascading includes

---

# 3. **不要写复杂的逻辑在头文件（难调试、难看报错）**

尤其是模板元编程复杂逻辑，一个错误能给你报上百行。

### ✔ 原则

* 只有“小逻辑”适合放 header
* 大逻辑放到 cpp（header-only 时可以用 `.inl` 分离）

例如：

```
my_lib.hpp
my_lib.inl
```

把实现放进 `.inl`，可读性会好很多。

---

# 4. **头文件中禁止使用 using namespace**

### ❌ 极其危险

```cpp
using namespace std;    // 污染用户命名空间
```

### ✔ 只能写在 cpp 中（但 header-only 没 cpp，只能不用）

如果必须 using，建议写成：

```cpp
namespace mylib {
    using std::string;
    using std::vector;
}
```

这样不会污染 user code。

---

# 5. **限制宏（#define）的使用**

header-only 一旦 define 出现：

* 污染命名空间
* 容易导致冲突
* 难调试

### ❌ 尽量不要写宏

```cpp
#define MAX_VALUE 1000
```

### ✔ 如果写宏，必须加唯一前缀防止冲突

```cpp
#define MYLIB_MAX_VALUE 1000
```

---

# 6. **避免在头文件中创建全局对象（多线程初始化顺序问题）**

例如：

```cpp
inline Logger globalLogger;   // 在多个 TU 中构造顺序不确定
```

会出现：

* 初始化顺序不确定
* 多线程冲突
* 稀有、难排查 Bug

### ✔ 正确写法（Meyers Singleton）

```cpp
Logger& GetLogger() {
    static Logger instance;
    return instance;
}
```

线程安全，初始化顺序确定。

---

# 7. **不要让头文件包含实现细节（泄漏依赖）**

### ❌ 不要这样写

```cpp
#include <Eigen/Dense>

class Pose {
    Eigen::Matrix4d T;
};
```

这样用户必须安装 Eigen。

### ✔ 用前向声明 + PIMPL（但 header-only 不常用）

或者至少用 opaque type：

```cpp
class Pose {
public:
    Pose();
    ~Pose();
private:
    struct Impl;
    Impl* pImpl;   // 不暴露细节
};
```

---

# 8. **避免写耗时的大 inline 函数（代码膨胀）**

Header-only 中逻辑太大 → 每个调用点都展开 → 可执行文件体积巨大。

### ❌ 不要这样：

```cpp
inline void big_function() {
    // 200 行逻辑
}
```

### ✔ 建议：

* 大逻辑写到 `.inl` 文件（仍然 header-only）
* 把复杂逻辑拆成小函数
* 不要盲目 inline，尽量让编译器决定

---

# 9. **模板类设计时，避免把模板类型影响整个头文件**

例如：

```cpp
template <typename T>
class Foo { ... };
```

你 include 一次 → 编译一次
所以模板要“轻”，否则编译爆炸。

---

# 10. **使用 pragma once 或 include guard**

否则重复 include 会爆炸。

---

# 11. **当心异常、静态变量、线程本地变量**

尤其是：

```cpp
thread_local int t;
```

不同 TU 会生成不同实例，不一定是你想要的行为。

---

# 12. **类型变动会导致所有文件重新编译**

Header-only 的缺点是：

* 粗改一个 tiny 函数
* 所有引用它的 cpp 全部重新编译（包括别人的工程）

所以头文件设计要稳定，变化要少。

---

# 📌 最后给你一份 **Header-only 编码注意事项 Checklist**

### ✔ 必须 inline 或模板化所有函数

### ✔ 全局变量必须 inline

### ✔ 避免 using namespace

### ✔ 避免大量 include

### ✔ 把实现拆到 `.inl`

### ✔ 避免复杂模板逻辑导致报错难看

### ✔ 避免头文件中创建对象

### ✔ 不要写太大 inline 函数

### ✔ reduce dependencies（减少暴露依赖）

### ✔ 多线程全局对象必须改为 static 局部变量

### ✔ 尽量不使用宏或保证宏命名唯一

---

# 如果你愿意，我还可以给你：

🔹 **一个最佳实践的 header-only 库模板结构**（含 .hpp + .inl）
🔹 **错误示例 vs 正确示例**
🔹 **你当前在写的代码的 header-only 风险检查**

你想要哪个？
