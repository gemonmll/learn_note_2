下面我把 **关键帧如何生成、IMU/LiDAR/Bias 因子如何计算** 用一步一步的方式讲清楚。
我会用 **LIOSAM / LIO-Livox / VINS-Fusion** 中通用的方式解释，让你完全理解后端图优化从哪里来的。

---

# 🌟 整体框架回忆

只要搞清楚图优化里：

1. **关键帧（Pose 节点）怎么产生**
2. **IMU 因子怎么构造**
3. **雷达因子怎么构造**
4. **Bias 因子怎么构造**

就完整了解因子图了。

我按这个顺序给你讲👇

---

# 1️⃣ 关键帧（Keyframe）如何计算？

关键帧是图优化中的节点（X0, X1, X2 ...），也就是 Pose3。

**关键帧不是每一帧传感器数据，关键帧要“触发”才生成。**

### LIO / VIO 中最常见的关键帧触发条件：

---

### ✔ 方式 1：固定时间间隔（常见于 VINS）

比如每 0.1 秒取一个关键帧。

---

### ✔ 方式 2：运动量触发（常见于 LIO-SAM）

例如位移 > 0.5m 或旋转 > 5° 时产生关键帧。

公式示例：

```
if |p_curr - p_last_kf| > 0.5m  or  |rotation_delta| > 5°
    生成一个关键帧
```

---

### ✔ 方式 3：雷达帧本身就是关键帧（LOAM 系）

例如：

* 每来一帧 LiDAR scan
* 运行 scan-to-map 估计位姿
* 这帧自动被当作关键帧加入后端

你提的系统就是这种：

**每一帧雷达里程计都对应关键帧。**

所以如果有 100 帧雷达 → 有 100 个关键帧。

---

# 2️⃣ IMU 因子（ImuFactor）如何计算？

IMU 因子来源于 **预积分（preintegration）**。

其过程如下：

### ✔ 步骤 1：IMU 原始测量插入队列 imuQueOpt

(加速度 a_t，角速度 ω_t)

---

### ✔ 步骤 2：找到两个关键帧之间的 IMU 数据

假设关键帧时刻是 t_i 和 t_j（一般是雷达帧对应的时间），
你取所有 IMU：

```
t_i < t_imu < t_j
```

---

### ✔ 步骤 3：预积分公式

对加速度和角速度进行积分（扣掉 bias），得到：

* ΔR（旋转增量）
* Δv（速度增量）
* Δp（位置增量）
* 协方差矩阵（噪声随时间传播）

GTSAM 提供现成的预积分器：

```cpp
preintegrated_imu_->integrateMeasurement(acc, gyro, dt);
```

---

### ✔ 步骤 4：构造 IMU 因子

```cpp
ImuFactor(X(i), V(i), X(j), V(j), preintegrated_imu_result);
```

这个因子连接：

* 位姿 X(i)、X(j)
* 速度 V(i)、V(j)

---

# 3️⃣ LiDAR 因子如何计算？

这取决于你使用的算法类型：

---

## 🅰 **方式 1：直接使用雷达里程计（外部给定） → LIO-SAM 的后端**

你在流程中提到：

> 1.7 构建雷达里程计因子，并加入因子图

说明你不是用 scan-to-map，而是**前端已经给你一个 LiDAR 相对 pose**。

通常是：

```
Pose_Lidar(i) → Pose_Lidar(j)
```

然后将该相对变换 T_ij 加入因子图：

```cpp
BetweenFactor<Pose3>( X(i), X(j), T_ij, LidarNoise )
```

注意你还提到：

> 1.6 只做平移对齐 IMU → 说明雷达坐标系需要外参转换

---

## 🅱 **方式 2：使用 ICP 或 Scan-to-Map**

如果你的前端自己算相对位姿：

```
T_ij = ICP(Scan_i, Scan_j)
```

也一样加 BetweenFactor：

```cpp
BetweenFactor<Pose3>(X(i), X(j), T_ij, noise)
```

---

# 4️⃣ Bias 因子 BetweenFactor 如何计算？

GTSAM 推荐加入：

```
BetweenFactor<imuBias::ConstantBias>( Bias(i), Bias(j), ZeroBias, Covariance )
```

作用：

* 限制偏差变化不要太剧烈（IMU bias 随时间慢漂）
* 如果漂得太快，优化器会察觉并修正

公式是：

```
Bias(j) - Bias(i) ≈ 0   （噪声很小）
```

所以它确保 bias 是连续的。

---

# 🔥 整合起来之后，因子图是这样：

关键帧（每一帧雷达）：

```
X0, V0, B0
X1, V1, B1
X2, V2, B2
...
```

因子：

```
Prior(X0, V0, B0)
IMU因子( X0,V0,B0 -> X1,V1,B1 )
LIDAR因子( X0 -> X1 )

IMU因子( X1,V1,B1 -> X2,V2,B2 )
LIDAR因子( X1 -> X2 )

BiasBetween因子( B0 -> B1 )
BiasBetween因子( B1 -> B2 )

...
```

---

# 🌟 最终答案（你问的核心）

> **关键帧如何算？——由雷达里程计触发（每一帧雷达是关键帧）**

> **IMU 因子如何算？——预积分（把 t_i 到 t_j 的 IMU 数据压缩成一个因子）**

> **雷达因子如何算？——根据雷达里程计前端给的相对位姿，用 BetweenFactor 表示**

> **Bias 因子？——限制 bias 连续性，用 BetweenFactor 表示零差分约束**

---

# 🎯 如果你愿意，我还能继续解释：

* 画一张因子图示意图（你会更直观）
* 解释 IMU 预积分的数学原理 ΔR, Δv, Δp
* 为什么每帧 LiDAR 直接作为关键帧？
* Keyframe 密度对精度和实时性的影响
* 给你一段完整的 GTSAM 后端代码结构

你想继续哪一部分？

--
 
## 第二部分 因子计算公式
 下面我把 **IMU 因子、雷达 Between 因子、Bias 因子、先验因子** 的公式全部用最清晰、实用的方式整理出来，
这些公式就是 **GTSAM/LIO-SAM/VINS-Fusion 后端** 的基础。

我会按照“概念 → 数学公式 → 实际方程 → 噪声模型”来讲。

---

# 🧩 因子图中的 4 大因子

1. **先验因子（PriorFactor）**
2. **IMU 预积分因子（ImuFactor）**
3. **雷达相对位姿因子（BetweenFactor）**
4. **Bias 连续性因子（BiasBetweenFactor）**

下面逐个展开。

---

# ⭐ 1. 先验因子（PriorFactor）

### **用途**：固定第一个关键帧，使图不会漂浮。

数学形式：

[
e = X - X_{prior}
]

协方差：

[
R_{\text{prior}}
]

误差项：

[
| e |*{R*{\text{prior}}}^{2}
= (X - X_{prior})^{T} R^{-1} (X - X_{prior})
]

GTSAM 中写法：

```cpp
graph.emplace_shared<PriorFactor<Pose3>>(X(0), X_prior, noisePrior);
```

---

# ⭐ 2. IMU 预积分因子（ImuFactor）

IMU 因子的核心是预积分结果：

* ΔR 旋转增量
* Δv 速度增量
* Δp 位置增量

它们来自 IMU 加速度 a 和角速度 ω：

---

### **2.1 原理：**

IMU 单帧公式（原始）：

[
\omega_m = \omega + b_g + n_g
]
[
a_m = R^T ( \ddot{p} - g ) + b_a + n_a
]

其中：

* ( b_g, b_a ) = gyro 和 accel 的 bias
* ( n_g, n_a ) = 传感器噪声

---

### **2.2 预积分定义**

IMU 在关键帧 i → j 之间连续积分，得到：

[
\Delta R_{ij},\ \Delta v_{ij},\ \Delta p_{ij}
]

它们满足：

[
R_j = R_i \Delta R_{ij} \cdot \text{exp}(J_r^g \delta b_g)
]

[
v_j = v_i + g\Delta t + R_i\Delta v_{ij} + J_v^b \delta b
]

[
p_j = p_i + v_i\Delta t + \frac{1}{2}g\Delta t^2 + R_i\Delta p_{ij} + J_p^b \delta b
]

GTSAM 用线性化的 Jacobian（J）自动处理 bias 的影响。

---

# ⭐  IMU 因子的误差项（GTSAM 中最关键）

IMU 因子的误差项是：

[
e =
\begin{bmatrix}
e_R \
e_v \
e_p
\end{bmatrix}
]

---

### ✔ 旋转误差：

[
e_R = \text{Log}\left( \Delta R_{ij}^{-1} ( R_i^{-1} R_j ) \cdot \text{CorrectBiasTerm} \right)
]

---

### ✔ 速度误差：

[
e_v = R_i^T (v_j - v_i - g\Delta t) - \Delta v_{ij} - J_v\delta b
]

---

### ✔ 位置误差：

[
e_p = R_i^T (p_j - p_i - v_i\Delta t - \frac{1}{2}g\Delta t^2)

* \Delta p_{ij} - J_p\delta b
  ]

噪声：

[
(e)^T \Sigma^{-1} e
]

这里的协方差 Σ 是预积分器传递过来的 IMU 噪声传播结果。

---

# ⭐ 3. 雷达 BetweenFactor（LiDAR Pose Factor）

你提到的雷达里程计因子一般是相邻雷达帧之间的相对位姿：

[
T_{ij} = T_i^{-1} T_j
]

误差项：

[
e = \text{Log} ( T_{ij}^{-1} ( T_i^{-1} T_j ) )
]

协方差：

[
e^T R_{\text{lidar}}^{-1} e
]

GTSAM 写法：

```cpp
graph.emplace_shared<BetweenFactor<Pose3>>( X(i), X(j), T_ij, lidarNoise );
```

---

# ⭐ 4. Bias 连续性因子（BiasBetweenFactor）

假设 bias 是一个随机游走：

[
b_{j} = b_i + n_{bias}
]

误差：

[
e_b = (b_j - b_i)
]

协方差：

[
e_b^T R_{bias}^{-1} e_b
]

GTSAM 写法：

```cpp
graph.emplace_shared<BetweenFactor<imuBias::ConstantBias>>(
    B(i), B(j), imuBias::ConstantBias(), biasRwNoise);
```

---

# ⭐ 因子图整体误差函数（最终优化目标）

所有因子的误差项加起来：

[
\min_{X,V,B} \sum e_{\text{prior}}

* \sum e_{\text{lidar}}
* \sum e_{\text{imu}}
* \sum e_{\text{bias}}
  ]

这就是 Bundle Adjustment / MAP 优化。

GTSAM 把这个目标函数自动转为稀疏矩阵求解。

---

# 🧠 总结（非常重要）

| 因子           | 公式结构                      | 含义           |
| ------------ | ------------------------- | ------------ |
| **先验因子**     | X - X_prior               | 固定起点         |
| **LiDAR 因子** | Log( T_ij⁻¹ (T_i⁻¹ T_j) ) | 雷达相对位姿约束     |
| **IMU 因子**   | ΔR, Δv, Δp 的预积分约束         | 提供高频速度/加速度信息 |
| **Bias 因子**  | b_j - b_i                 | 限制 bias 平滑变化 |

---

# 🎁 如果你愿意，我可以继续提供：

✔ 一张“因子图结构图”
✔ 每个因子在 GTSAM 中的源码解释
✔ IMU 预积分的详细推导（Forster 的论文）
✔ 一份你能直接用的 C++ 伪代码（IMU + LiDAR 后端完整流程）

你想继续哪一部分？
